# 面向对象程序设计基础

## L1_绪论

#### 命令提示符

cd 显示当前目录

mkdir OOP2020 在当前目录下新建OOP2020目录

type nul>a.cpp 在当前目录下新建a.cpp文件

dir 查看当前目录下的文件

cd.. 进入上一层目录


cd OOP2020 进入OOP2020目录

del a.cpp 删除a.cpp文件

rmdir /s OOP2020 删除OOP2020目录以及目录下所有文件

move a.cpp OOP2020\ 将a.cpp移动至OOP2020目录

copy a.cpp OOP2020\ 将a.cpp拷贝至OOP2020目录下

xcopy /e a OOP2020 将a目录下的所有文件拷贝到OOP2020目录下

## L2_编程环境

#### 源程序的结构、编译、链接

g++ -c ex1.cpp -o ex1.o 只编译不链接；g++ ex1.o -o ex1.out 编译并链接；

外部函数的声明（一般声明在头文件中）只是令程序顺利通过编译，此时并不需要搜索到外部函数的实现（或定义）；在链接过程中，外部函数的实现（或定义）才会被寻找和添加进程序，一旦没有找到函数实现，就无法成功链接。

#### 头文件

使用原因：有时辅助函数(如全局函数)会在多个源文件中被使用
头文件(.h)：避免反复编写同一段声明；统一辅助函数的声明，避免错误
#include 预编译指令：将被包含的文件代码，直接复制到当前文件；一般被用于包含头文件（实际也能包含任意代码）

#### 声明与定义：

**定义=声明+内存分配**

##### 函数

函数声明：int ADD(int a, int b)；int ADD(int, int);  


函数定义（也叫实现）int ADD(int a, int b) {return a + b;}

同一个函数可以有多次声明，但只能有一次实现

##### 变量

int x在声明变量的同时也是定义变量，只是未初始化变量

变量的声明：extern关键字  extern int x 声明变量

extern关键字也可以用于函数声明，但extern对于函数声明不是必须的

##### 为什么只在头文件(.h)进行函数声明而不实现（定义）函数体？

若函数没定义成局部函数而又有多个cpp文件包含此头文件，在链接时因发现多个相同的函数实现而发生错误；换句话说，如果把定义放进头文件中，每include一次头文件，标识符对应函数就被定义一次，重复定义在多文件的编译连接时容易出问题。

#### 宏定义

#define是C++语言中的一个预编译指令，它用来将一个标识符定义为一个字符串，该标识符被称为宏名，被定义的字符串称为替换文本；在程序被编译前，先将宏名用被定义的字符串替换，这称为宏替换，替换后才进行编译，宏替换是简单的替换。

##### 防止头文件被重复包含

（1）#ifndef __BODYDEF_H__
          #define __BODYDEF_H__ 
          // 头文件内容 
          #endif

（2）#pragma once
          // 头文件内容

#### Makefile

##### 格式：`<target> : <prerequisites>`

​             `[tab]		<command>`           注：Makefile中注释以#开头

##### Makefile常见语法

（1）使用匹配符%，可以将大量同类型的文件，只用一条规则就完成构建。

（2）Makefile 允许使用等号自定义变量。调用时，变量需要放在 $( ) 之中。Makefile一共提供了四个赋值运算符 （=、:=、？=、+=）可对变量进行赋值。

（3）$@指代当前目标，就是Make命令当前构建的那个目标；$< 指代第一个前置条件；$^ 指代所有前置条件，之间以空格分隔。

（4）Makefile可以调用内在函数。

wildcard 函数：用于检索文档中特定后缀的文件

subst 函数：用于文本替换 eg：$(subst ee,EE,feet on the street）

patsubst 函数：用于模式匹配的替换

 eg：$(patsubst %.c,%.o,x.c.c bar.c) 将x.c.c和bar.c替换为x.c.o和bar.o

if函数：

``ifeq (TRUE, $(var))`
     `# do something`
 endif`

#### 程序命令行参数

int main(int argc, char* argv[])
在上面代码中，argc 表示命令行输入参数的个数（以空白符分隔），argv 中存储了所有的命令行参数。

#### GDB调试工具

g++ -g a.cpp –o a.out编译程序
-g 在可执行程序中包含标准调试信息
gdb a.out 调试a.out程序

## L3_封装与接口

#### 函数重载与缺省值

多个同名的函数实现之间，必须保证至少有⼀个函数参数的类型有区别。**返回值、参数名称**等不能作为区分标识。

当函数重载时，会优先调用类型匹配的函数实现，否则才会进行类型转换

函数参数可以在定义时**设置默认值（缺省值）**，这样在调用该函数时，若不提供相应的实参，则编译自动将相应形参设置成缺省值

有缺省值的函数参数，必须是最后⼀个参数；如果有多个带缺省值的函数参数，则这些函数参数都只能在没有缺省值的参数后面出现

#### auto关键字

（1）由编译器根据上下文自动确定变量的类型

（2）追踪返回类型的函数

声明形式：auto func(char* ptr, int val) -> int;

auto 变量必须**能够在编译期确定其类型**；auto 变量必须在**定义时初始化**；**函数参数不能被声明为auto**；auto并不是⼀个真正的类型。不能使用⼀些**以类型为操作数的操作符**，如sizeof或者typeid

#### 内存申请与释放

格式：Type* pointer = new Type

​            Type* pointer = new Type[N]

int * foo；foo = new int [5]；

这里，foo是一个指针，因此，foo指向的第一个元素可以使用表达式foo [0]或表达式* foo（两者都是等价的）来访问。

delete关键字用于内存释放

eg：delete ptr; // 删除指针变量所指单个内存单元；delete[] array; // 删除多个单元组成的内存块

#### 零指针

NULL指针同时也是被定义为0的int常量；nullptr为严格的零指针

#### 类

类的成员分类：

public：被public修饰的成员可以在类外访问。

private：默认权限；被private修饰的成员不允许在类外访问

protected：对于子类来说，就是public的，可以自由使用，没有任何限制；而对于其他的外部class，protected就变成private。

在类内可以用.访问所有成员，类外可用.访问public成员

#### 内联函数

宏定义与内联函数的区别：使用内联函数，编译器自动产生**等价的**表达式；编译器会将所有宏定义的代码，**直接拷贝**到被调用的地方

注意事项：避免对大段代码使用内联修饰符；避免对包含循环或者复杂控制结构的函数使用内联定义；

避免将内联函数的声明和定义分开（在头文件中声明并实现）；定义在类声明中的函数默认为内联函数；

⼀般构造函数、析构函数都被定义为内联函数

## L4_创建与销毁

### 构造函数

构造函数没有返回值类型，函数名与类名相同；类的构造函数可以重载，即可以使用不同的函 参数进行对象初始化

#### 初始化列表

构造函数可以使用初始化列表初始化成员数据；该列表在定义构造函数时使用，**位置在函数体之前、函数参数列表之后**，以冒号作开头。使用“**数据成员(初始值)**”的形式

eg：`class Student { `

`int ID;//声明 `

`public: `

`Student(int id) : ID(id) { } `

`Student(int year, int order) {  ID = year * 10000 + order;  }`

注意：**初始化列表的成员是按照声明的顺序初始化的，而不是按照出现在初始化列表中的顺序**

在构造函数的初始化列表中，还可以调用其他构造函数，称为“委派构造函数”

#### 默认构造函数

不带任何参数的构造函数，或每个形参提供默认实参的构造函数，被称为“默认构造函数”，也称“缺省构造函数”

ClassName a; //调用默认构造函数
ClassName b = ClassName(); //同样调用默认构造函数

注意：**会自动调用成员变量的默认构造函数**：即先调用成员变量的构造，再执行自己的构造函数

##### 隐式定义默认构造函数

若用户已经定义了其他构造函数，编译器将不会隐式合成默认构造函数

注意：此时如果再编写Classname a将**显示编译错误**，因为编译器不会再合成默认构造函数；出于某些需要，我们可以手动指定生成默认版本的构造函数：即便其他构造函数存在，编译器也会定义隐式默认构造函数，格式为：**Classname（）=default；**

##### 显式删除构造函数

使用delete显式地删除构造函数，避免产生未预期行为的可能性。

eg：`A(char ch) = delete;` 

### 析构函数

清除对象占用的资源是无条件的，不需要任何选项。因此，析构函数没有参数，且**只有⼀个（即清除方式唯⼀）**

形式：~类名（）；   没有函数返回值，没有函数参数

含有成员变量时，**先执行自己的析构函数**，再调用成员变量的析构

#### 隐式定义的析构函数

 和构造函数类似，当用户没有自定义析构函数时，编译器会自动合成⼀个隐式的析构函数

**注意：隐式定义的析构函数不会delete指针成员**

### 全局对象与局部对象

#### 全局对象

在**main()函数调用之前**进行初始化；在同⼀编译单元中，按照定义顺序进行初始化；不同编译单元中，对象初始化顺序不确定；在main()函数**执行完return之后**，对象被析构。

#### 局部对象

在程序执行到该局部对象的代码时被初始化；在局部对象生命周期结束、即所在作用域结束后被析构。

注意：<u>**尽量少用全局对象**</u>

全局对象的构造顺序不能完全确定，所以全局对象之
间不能有依赖关系，否则会出现问题；全局对象会增⼤代码的耦合性，导致程序难以复用或者测试；**使用参数来替代全局对象**

### 引用

具名变量的别名：类型名 & 引用名=变量名

eg：`int v0; int & v1 = v0;` v1是变量v0的引用，它们在内存中是同⼀单元的两个不同名字

**引用必须在定义时进行初始化，且不能修改引用指向**

#### 函数中的引用

函数参数可以是引用类型，表示函数的形式参数与实际参数是同⼀个变量，改变形参将改变实参。

eg：`void swap(int& a, int& b)`
`{ int tmp = b; b = a; a = tmp; }`

调用此函数可以达到交换实参值的效果

**函数返回值可以是引用类型，但不得指向函数的临时变量**

**<u>当函数返回值为引用类型时，可以理解为函数返回了一个指向返回变量的指针，但是这个指针发挥变量的作用，按照变量进行操作，称之为函数别名</u>**

#### 指针与引用的区别

1、不存在空引用。引用必须连接到⼀块合法的内存。
2、⼀旦引用被初始化为⼀个对象，就不能被指向到另⼀个对象。指针可以在任何时候指向到另⼀个对象。
3、引用必须在创建时被初始化为⼀个对象。指针可以在初始化时置空，之后再指向对象。

### 运算符重载

运算符重载需要按规则声明执行该运算的函数

运算重载⼀般有两种方式**（注意参数不同）**

（1）全局函数的运算符重载
`A operator+(A a, A b) {…}`

（2）成员函数的运算符重载
`class A{`
`int data;`
`public:`
`A operator+(A b) {…};`

`}`

只能成员函数重载的运算符

=,[],(),->只能通过成员函数来重载

原因：当没有自定义operator=时，编译器会自动合成⼀个
默认版本的赋值操作；在类内定义operator=，编译器则不会自动合成；如果允许使用全局函数重载，可能会对是否自动合成
产生干扰

## L5_创建与销毁2

### 友元函数

#### 友元

被声明为友元的函数或类，具有对出现友元声明的类的private及protected成员的访问权限，即可以访问该类的⼀切成员。
**友元的声明只能在类内进行**

被友元声明的函数不一定是当前类的成员函数，即使该函数的定义写在当前类内；当前类的成员函数也不需要友元修饰

可以声明别的类的成员函数，为当前类的友元。其中，构造函数、析构函数也可以是友元。

友元的声明与当前所在域是否为private或public无关

⼀个普通函数可以是多个类的友元函数

可对class/struct/union进行友元声明，代表该类的所有成员函数均为友元函数；对基础类型的友元声明会被忽略（因为没有实际价
值）；编译器可能会发出警告，但不会认为是错误

注意：

• **非对称关系**：类A中声明B是A的友元类，则B可以访问A的私有成员，但A不能访问B的私有成员。
• **友元不传递**：朋友的朋友不是你的朋友
• **友元不继承**：朋友的孩⼦不是你的朋友
• **友元声明不能定义新的class**

### 静态变量与函数

#### 静态变量

使用static修饰的变量；

初始化：初次定义时需要初始化，且只能初始化⼀次。
静态局部变量存储在静态存储区，生命周期将持续到整个程序结束
静态全局变量是内部可链接的，作用域仅限其声明的文件，不能被其他文件所用，可以避免和其他文件中的同名变量冲突

#### 静态函数

使用static修饰的函数；

静态函数是内部可链接的，作用域仅限其声明的文件， 不能被其他文件所用，可以避免和其他文件中的同名函数冲突

**静态与非静态的区别：**

静态全局变量/静态函数是内部可链接的，作用域仅限其声明的文件，不能被其他文件所用；
非静态全局变量/非静态全局函数是外部可链接的，可以被其他文件所用

#### 静态数据成员

静态数据成员：使用static修饰的数据成员，是隶属于类的，称为类的静态数据成员，也称“类变量”

• 静态数据成员被该类的所有对象共享（即所有对象中的这个数据域处在同⼀内存位置）
• 类的静态成员（数据、函数）既可以通过对象来访问，也可以通过类名来访问，如ClassName::static_var或者a.static_var（a为ClassName类的对象）
• 类的静态数据成员要在实现⽂件中赋初值，格式为：Type ClassName::static_var = Value;

注意：

**静态数据成员应该在.h文件中声明，在.cpp文件中定义。在.h文件中定义后在多个文件中会被多次定义，编译错误**

#### 静态成员函数

静态成员函数：在返回值前面添加static修饰的成员函数，称为类的静态成员函数

和静态数据成员类似，类的静态成员函数既可以通过对
象来访问，也可以通过类名来访问，如ClassName::static_function或者a.static_function(a为ClassName类的对象）

##### 静态函数的访问权限

<u>• 静态成员函数属于整个类，在类实例化对象之前已经分配了内存空间。</u>
<u>• 类的非静态成员必须在类实例化对象后才分配内存空间。</u>
<u>• 如果使用静态成员函数访问非静态成员，相当于没有定义⼀个变量却要使用它。</u>

### 常量

常量关键字const常用于修饰变量、引用/指针、函数返回值等；

<u>• 修饰变量时（如const int n = 1;），必须就地初始化，该变量的值在其生命周期内都不会发生变化</u>
<u>• 修饰引用/指针时（如int a=1; const int& b=a;），不能通过该引用/指针修改相应变量的值，常用于函数参数以保证函数体中无法修改参数的值</u>
<u>• 修饰函数返回值时（如const int* func() {…}），函数返回值的内容（或其指向的内容）不能被修改</u>

#### 常量数据成员

常量数据成员：使用const修饰的数据成员，称为类的常量数据成员，在对象的整个生命周期里不可更改

##### 常量数据成员初始化

• 构造函数的初始化列表中被初始化
• 就地初始化
• **不允许在构造函数的函数体中通过赋值来设置**

#### 常量成员函数

成员函数也能用const来修饰，称为常量成员函数。

常量成员函数的访问权限：实现语句不能修改类的数据成员，即不能改变对象状态（内容）

格式：`ReturnType Func(…) const {…}`

**注意区别：`const ReturnType Func(…) {…}`（返回值为常量）**

常量对象：对象中的“数据”不能变；若对象被定义为常量(const ClassName a;)，则它只能调用以const修饰的成员函数

#### 常量静态变量

常量静态变量需要在类外进行定义；但有两个例外：**<u>int和enum类型可以就地初始化</u>**

**注意：不存在常量静态函数**
• 静态函数隶属于类，可以不实例化而直接通过类名访问
• 常量/非常量函数的访问权限需要通过实例化后的对象是否为常量对象来决定。常量修饰函数必须绑定在对象上； 因此，静态函数和常量函数互相冲突

<img src="C:\Users\dyh20200207\AppData\Roaming\Typora\typora-user-images\image-20210322204349742.png" alt="image-20210322204349742" style="zoom:50%;" />

### 特殊对象的构造与析构

#### 常量对象的构造与析构

**常量全局/局部对象的构造与析构时机和普通全局/局部对象相同**

#### 静态对象的构造与析构

静态全局对象的构造与析构时机和普通全局对象相同

##### 函数中的静态对象

<u>• 在程序执行到该静态局部对象的代码时被初始化。</u>
<u>• 离开作用域不析构。</u>
<u>• 第⼆次执行到该对象代码时，不再初始化，直接使用上⼀次的对象</u>
<u>• 在main()函数结束后被析构。</u>

##### 类静态对象

类A的对象a作为类B的静态变量

<u>• a的构造与析构表现和全局对象类似，即在main()函数调用之前进行初始化，在main()函数执行完return，程序结束时，对象被析构</u>
**<u>• 和B是否实例化无关</u>**

#### 参数对象的构造与析构

##### 传递的是形参

<u>• 在函数被调用时，b被构造，调用拷贝构造函数进行初始化。默认情况下，对象b的属性值和a⼀致。</u>
<u>• 在函数结束时，调用析构函数，b被析构。</u>

注意：**当函数被调用后，如果传入的形参是一个对象，那么函数调用结束后这个对象作为函数变量会被析构一次，在return结束后还会作为全局变量被再次析构**

##### 传递的是类的引用

<u>• 在函数被调用时，b不需要初始化，因为b是a的引用。</u>
<u>• 在函数结束时，也不需要调用析构函数，因为b只是⼀个引用，而不是A的对象。</u>

##### 传递的类中含有指针成员

• 对象a（函数内）和对象object_a的data成员⼀样（地址⼀样），所以delete的时候释放的是同⼀块内存地址。
• 对象a（函数内）析构时不会出错。但对象object_a析构时，因为试图释放⼀块已经释放过的内存，所以会出错。即析构了两次，但两个指针指向的是同一块内存地址，所以第二次析构会出错。

注意：**尽量使用对象引用作为参数**，这样不会出现指针变量被重复析构的报错。

#### 对象的new和delete

同时使用new[]和delete会导致内存泄漏

## L6_引用与复制

### 拷贝构造函数

拷贝构造函数是⼀种特殊的构造函数，它的参数是语言规定的，是同类对象的常量引用，格式：`Person(const Person& src) { id = src.id; ... }`

拷贝函数被调用的常见情况：

（1）用⼀个类对象定义另⼀个新的类对象

`Test a; Test b(a);`或`Test c = a;`

（2）函数调用时以类的对象为形参

`Func(Test a）`

（3）函数返回类对象

`Test Func(void)`

编译器会自动调用“拷贝构造函数”，在已有对象基础上生成新对象。

如果调用拷贝构造函数且当前没有给类显式定义拷贝构造函数，编译器将自动合成“隐式定义的拷贝构造函数”，其功能是调用所有数据成员的拷贝构造函数或拷贝赋值运算符。

对于基础类型来说，默认的拷贝方式为**位拷贝** ，即直接对整块内存进行复制。

**<u>注意：位拷贝在遇到指针类型成员时可能会出错, 导致多个指针类型的变量指向同⼀个地址</u>**<u>**；当类内含指针类型的成员时，为避免指针被重复删除，不应使用隐式定义的拷贝构造函数**</u>

<img src="C:\Users\dyh20200207\AppData\Roaming\Typora\typora-user-images\image-20210330185526123.png" alt="image-20210330185526123" style="zoom:33%;" />

<u>如何减少拷贝函数的使用：</u>

<u>（1）使用引用/常量引用传参数或返回对象；</u> 

<u>（2）将拷贝构造函数声明为private；</u> 

<u>（3）用delete关键字让编译器不生成拷贝构造函数的隐式定义版本。</u>

### 右值引用

#### 左值和右值

左值：可以取地址、有名字的值；并且可以被&引用（左值引用）

右值：不能取地址、没有名字的值;常见于常值、函数返回值、表达式

#### 右值引用

虽然右值无法取地址，但可以被&&引用(右值引用)

eg：`int &&e = a + b;` 

**注意：右值引用无法绑定左值**，即左值引用能绑定左值，右值引用能绑定右值；特殊的，**常量左值引用既能绑定左值能也绑定右值**

**注意：所有的引用（包括右值引用）本质上都是左值**

### 移动构造函数

右值引用可以延续即将销毁变量的生命周期，用于构造函数可以提升处理效率，在此过程中尽可能少地进行拷贝；使用右值引用作为参数的构造函数叫做移动构造函数；eg：`ClassName(ClassName&& VariableName);`

移动构造与拷贝构造的区别：**最主要的差别就是类中堆内存是重新开辟并拷贝，还是直接将指针指向那块地址。**对于⼀些即将析构的临时类， 移动构造函数直接利用了原来临时对象中的堆内存，新的对象无需开辟内存，临时对象无需释放内存，从而大大提高计算效率。

#### move函数

加快左值初始化的构造速度：std::move函数;eg：`Test b=std::move(a);`

输入：左值，包括变量等，该左值⼀般不再使用；返回值：该左值对应的右值

**<u>注意：move函数本身不对对象做任何操作，仅做类型转换， 即转换为右值。</u>**

### 拷贝/移动构造函数的调用时机

#### 拷贝构造函数

（1）用⼀个类对象/引用/常量引用初始化另⼀个新的类对象 

（2）以类的对象为函数形参，传入实参为类的对象/引用/常量引用 

（3）函数返回类对象（类中未显式定义移动构造函数，不进行返回值优化）

#### 移动构造函数

（1）用⼀个类对象的右值初始化另⼀个新的类对象（常配合 std::move函数⼀起使用）: `Test b = func(a); Test b = std::move(a);`**与Test b = a; 不同**

（2）以类的对象为函数形参，传⼊实参为类对象的右值（常配合 std::move函数⼀起使用）: `func(Test());func(std::move(a));`**与func(a)不同**

（3）函数返回类对象（类中显式定义移动构造函数，不进行返回值优化）

#### 拷贝赋值运算符

已定义的对象之间相互赋值，可通过调用对象的“拷贝赋值运算符函数”来实现

**赋值重载函数必须要是类的非静态成员函数，不能是友元函数。**

#### 移动赋值运算符

与拷贝赋值运算符类似

#### 编译器自动合成的函数/运算符

默认构造函数

拷贝构造函数

移动构造函数

拷贝赋值运算符

移动赋值运算符

析构函数

### 类型转换

自动类型转换可通过定义特定的转换运算符和构造函数来完成；在有必要的时候还可以进行强制类型转换

自动类型转换要求：**类内声明成员函数；无返回值类型**

#### 禁止自动类型转换

##### explicit修饰词

如果用explicit修饰类型转换运算符或类型转换构造函数，则相应的类型转换必须显式地进行；eg：`explicit operator Dst() const;`或`explicit Dst(const Src& s);`

#### 强制类型转换

##### cast关键字

const_cast，去除类型的const或volatile属性。

static_cast，类似于C风格的强制转换；无条件转换，静态类型转换。

dynamic_cast，动态类型转换，如派生类和基类之间的多态类型转换。

reinterpret_cast，仅仅重新解释类型，但没有进行二进制的转换。

## L7_组合与继承

### 组合

子对象构造时若需要参数，则应在**当前类的构造函数的初始化列表中**进行。若使用默认构造函数来构造子对象，则不用做任何处理。

#### 对象构造与析构函数的次序

• 先完成子对象构造，再完成当前对象构造 

• 子对象构造的次序仅由在类中声明的次序所决定

 • 析构函数的次序与构造函数相反

### 继承

被继承的已有类，被称为基类(base class)， 也称“父类”。

通过继承得到的新类，被为派生类(derived class，也称“子类”、“扩展类”。

#### 继承方式

`class Derived : [private] Base { .. };` 

<u>**缺省继承方式为private继承。**</u>

`class Derived : public Base { ... };` 

`class Derived : protected Base { ... };`

#### 不能继承的内容

**构造函数（可使用using进行继承）**

**析构函数**

**赋值运算符**

**友元函数**

#### 派生类的构造与析构

基类中的数据成员，通过继承成为派生类对象的一部分，需要在构造派生类对象的过程中调用基类构造函数来正确初始化。

• 若没有显式调用，则编译器会自动调用基类的默认构造函数。

 • 若想要显式调用，则只能在派生类构造函数的初始化成员列表中进行，既可以调用基类中不带参数的默认构造函数，也可以调用合适的带参数的其他构造函数。

**<u>注意：可以调用基类的构造函数，但不能在初始化列表中直接对基类成员进行初始化</u>**

- 先执行基类的构造函数来初始化继承来的数据，再执行派生类的构造函数。 

- 对象析构时，先执行派生类析构函数，再执行由编译器自动调用的基类的析构函数
- 在派生类中使用 `using Base::Base;` 来继承基类构造函数，相当于给派生类“定义”了相应参数的构造函数
- 当基类存在多个构造函数时，使用using会给派生类自动构造多个相应的构造函数。

注意：

- 如果基类的某个构造函数被声明为私有成员函数，则不能在派生类中声明继承该构造函数。

- 如果派生类使用了继承构造函数，编译器就不会再为派生类生成隐式定义的默认构造函数

#### 成员访问权限！！！

<img src="C:\Users\dyh20200207\AppData\Roaming\Typora\typora-user-images\image-20210420170421250.png" alt="image-20210420170421250" style="zoom:50%;" />

若是使用private/protected继承方式，则成为派生类私有/保护成员，不能被派生类的对象访问。若想让某成员能被派生类的对象访问，可在派生类 public部分用关键字using声明它的名字。

### 组合与继承

- 组合：嵌入一个对象以实现新类的功能

  <img src="C:\Users\dyh20200207\AppData\Roaming\Typora\typora-user-images\image-20210420170657754.png" alt="image-20210420170657754" style="zoom:50%;" />

- 继承：沿用已存在的类提供的接口

  <img src="C:\Users\dyh20200207\AppData\Roaming\Typora\typora-user-images\image-20210420170718816.png" alt="image-20210420170718816" style="zoom:50%;" />

### using关键字

常见用途：

继承基类构造函数

恢复被屏蔽的基类成员函数

指示命名空间 using namespace std

将另一个命名空间的成员引入当前空间 using std::cout

定义类型别名 using a=int

### 多重继承

派生类同时继承多个基类

#### 潜在问题

- 如果派生类D继承的两个基类A,B，是同一基类Base的不同继承，则A,B中继承自Base的数据成员会在D有两份独立的副本，可能带来数据冗余。
- 如果派生类D继承的两个基类A,B，有同名成员a，则访问D中a时，编译器无法判断要访问的哪⼀个基类成员。

## L8_虚函数

### 向上类型转换

- 派生类对象/引用/指针转换成基类对象/引用/指针，称为向上类型转换。**只对public继承有效**，在继承图上是上升的；对private、protected继承无效。

- 向上类型转换（派生类到基类）可以由编译器自动完成， 是⼀种**隐式类型转换**。

- 凡是接受基类对象/引用/指针的地方（如函数参数），都可以使用派生类对象/引用/指针，编译器会自动将派生类对象转换为基类对象以便使用。

### 函数调用捆绑

- 把函数体与函数调用相联系称为**捆绑**。
- 当捆绑在程序运行之前（由编译器和连接器）完成时，称为早捆绑，即运行之前已经决定了函数调用代码到底进入哪个函数
- 当捆绑根据对象的实际类型发生在程序运行时，称为晚捆绑，又称动态捆绑或运行时捆绑。
- **<u>晚捆绑只对类中的虚函数起作用，使用 virtual 关键字声明虚函数</u>**
- <u>**晚捆绑只对指针和引用有效**</u>

### 虚函数

- 对于被派生类重新定义的成员函数，若它在基类中被声明为虚函数，则通过基类指针或引用调用该成员函数时，编译器将根据所指（或引用）对象的**实际类型**决定是调用基类中的函数，还是调用派生类重写的函数
- 若某成员函数在基类中声明为虚函数，当派生类重写覆盖它时，无论是否声明为虚函数，该成员函数都仍然是虚函数

<img src="C:\Users\dyh20200207\AppData\Roaming\Typora\typora-user-images\image-20210425184122570.png" alt="image-20210425184122570" style="zoom:50%;" />

#### 虚函数表

- 每个包含虚函数的类用于存储虚函数地址的表(虚函数表有唯⼀性，即没有重写虚函数)
- 每个包含虚函数的类对象中，编译器秘密地放⼀个指针， 称为虚函数指针，指向这个类的 VTABLE
- 当通过基类指针做虚函数调用时，编译器静态地插入能取得这个VPTR并在VTABLE表中查找函数地址的代码，这样就能调用正确的函数并引起晚捆绑的发生。

#### 虚函数与构造函数、析构函数

##### 构造函数

- 当创建⼀个包含有虚函数的对象时，必须初始化它的VPTR以指向相应的VTABLE。设置VPTR的工作由构造函数完成。编译器在构造函数的开头秘密的插入能初始化VPTR的代码。
- **<u>构造函数不能也不必是虚函数。</u>**
- 在构造函数中调用一个虚函数，被调用的只是这个函数的本地版本(**即当前类的版本**)，即**虚机制在构造函数中不工作**。

##### 析构函数

- 析构函数能是虚的，且常常是虚的。虚析构函数仍需定义函数体。
- 虚析构函数的用途：当删除基类对象指针时，编译器将根据指针所指对象的**实际类型**，调用相应的析构函数
- 在析构函数中调用⼀个虚函数，被调用的只是这个函数的**本地版本**，即**虚机制在析构函数中不工作**。
- 重要原则：**<u>总是将基类的析构函数设置为虚析构函数</u>**

### 重载、重写覆盖与重写隐藏

1. 重载：函数名必须**相同**，函数参数必须**不同**，作用域**相同**(同 ⼀个类，或同为全局函数)，**返回值可以相同或不同**。

2. 重写覆盖：派生类重新定义基类中的虚函数，函数名必须**相同**， 函数参数必须**相同**，返回值**⼀般情况应相同**

   ​					派生类的虚函数表中原基类的虚函数指针会被派生类中重新定义的虚函数指针覆盖掉

3. 重写隐藏：派生类重新定义基类中的函数，函数名**相同**，但是参数**不同**或者基类的函数**不是虚函数**。

   ​					**重写隐藏中虚函数表不会发生覆盖。**

#### 重写覆盖与重写隐藏

相同点：

- 都要求派生类定义的函数与基类**同名**。
- 都会屏蔽基类中的同名函数，即**派生类的实例无法调用基类的同名函数**

不同点：

- 重写覆盖要求基类的函数是虚函数，且函数参数相同，返回值⼀般情况应相同；重写隐藏要求基类的函数不是虚函数或者函数参数不同
- 重写覆盖会使派生类虚函数表中基类的虚函数的指针被派生类的虚函数指针覆盖；重写隐藏不会。

<img src="C:\Users\dyh20200207\AppData\Roaming\Typora\typora-user-images\image-20210425190507525.png" alt="image-20210425190507525" style="zoom:50%;" />

<img src="C:\Users\dyh20200207\AppData\Roaming\Typora\typora-user-images\image-20210425190701892.png" alt="image-20210425190701892" style="zoom:50%;" />

<img src="C:\Users\dyh20200207\AppData\Roaming\Typora\typora-user-images\image-20210425190739814.png" alt="image-20210425190739814" style="zoom:50%;" />

#### override关键字

override关键字明确地告诉编译器⼀个函数是对基类中⼀个虚函数的重写覆盖，编译器将对重写覆盖要满足的条件进行检查，正确的重写覆盖才能通过编译

#### final关键字

- 在虚函数声明或定义中使用时，final确保**函数为虚**且**不可被派生类重写**。可在继承关系链的“中途”进行设定，禁止后续派生类对指定虚函数重写
- 在类定义中使用时，final指定**此类不可被继承**

eg：`void foo() final {}`

## L9_多态与模板

### 纯虚函数与抽象类

#### 纯虚函数

虚函数还可以进一步声明为纯虚函数，包含纯虚函数的类，通常被称为“抽象类”。

eg：`virtual 返回类型 函数名（形式参数）=0；`

#### 抽象类

含有至少一个纯虚函数。

- **不允许定义对象**
- 只能为派生类提供接口
- 能避免对象切片：确保只有**指针和引用**能够进行向上类型转换

基类纯虚函数被派生类重写覆盖之前仍是纯虚函数。因此当继承一个抽象类时，除**纯虚析构函数**外，必须**实现所有纯虚函数**，否则 继承出的类也是**抽象类**。

#### 纯虚析构函数

- 纯虚析构函数**仍然需要函数体** 
- 使基类成为抽象类，不能创建基类的对象。如果有其他函数是纯虚函数，则析构函数无论是否为纯虚的，基类均为抽象类。
- 对于纯虚析构函数而言，即便派生类中不显式实现，编译器也会自动合成默认析构函数。因此只要派生类覆盖了其他纯虚函数，该派生类就不是抽象类，可以定义派生类对象。

### 向下类型转换

#### dynamic_cast

- C++提供了一个特殊的显式类型转换，称为dynamic_cast，是一种安全的向下类型转换
- 使用dynamic_cast的对象**必须有虚函数**，因为它使用了存储在虚函数表中的信息判断实际的类型
- 使用方法：
  1. obj_p，obj_r分别是T1类型的指针和引用
  2. `T2* pObj = dynamic_cast<T2*>(obj_p);`转换为T2指针，运行时失败返回**nullptr**
  3. `T2& refObj = dynamic_cast<T2&>(obj_r);`转换为T2引用，运行时失败抛出**bad_cast**异常

#### static_cast

1. obj_p，obj_r分别是T1类型的指针和引用 
2. `T2* pObj = static_cast(obj_p);` //转换为T2指针
3.  `T2& refObj = static_cast(obj_r);` //转换为T2引用

<u>不安全：**不保证指向目标是T2对象**，可能导致非法内存访问</u>

#### 二者对比

不同点：

- static_cast在**编译时**静态执行向下类型转换。
- dynamic_cast会在**运行时**检查被转换的对象是否确实是正确的派生类。
- 一般**使用dynamic_cast进行向下类型转换**

### 多态

按照基类的接口定义，调用指针或引用所指对象的接口函数，函数执行过程因对象实际所属派生类的不同而呈现不同的效果（表现），这个现象 被称为“多态”。

**<u>产生多态的条件：继承 && 虚函数 && 引用或指针</u>**

### 函数模板与类模板

#### 函数模板

定义函数模板的方法：

`template <typename T>` 

 `ReturnType Func(Args)；`

注：**typename也可换为class**

- 函数模板在调用时，编译器能自动推导出实际参数的类型
- 调用类型需要满足函数的要求
- 当多个参数的类型不一致时，无法推导
- 可以手工指定调用类型  **eg：`sum<int>(2,3.2)`**
- **<u>函数模板库必须在头文件中实现，不可以分开编译，即声明与实现不可以分开</u>**

#### 类模板

定义方法：

<img src="C:\Users\dyh20200207\AppData\Roaming\Typora\typora-user-images\image-20210513235528622.png" alt="image-20210513235528622" style="zoom: 50%;" />

注：类模板的成员函数可在类外定义

eg：`void A<T>::print() { cout << data << endl; }`

##### 类模板的模板参数

- 类型参数：使用typename或class标记
- 非类型参数：整数，枚举，指针（指向对象或函数）， 引用（引用对象或引用函数）。无符号整数(unsigned) 比较常用。
- <u>所有模板参数必须在编译期确定，不可以使用变量。(可以使用常量或者具体数值)</u>

eg：

`template <typename T,unsigned size>`

`class array {` 

`T elems[size];`

 `};` 

`array<char 10> array0;`

##### 成员函数模板

普通类的成员函数，可以定义为模板函数：

<img src="C:\Users\dyh20200207\AppData\Roaming\Typora\typora-user-images\image-20210514105443937.png" alt="image-20210514105443937" style="zoom:50%;" />

模板类的成员函数，也可含有额外的模板参数：

<img src="C:\Users\dyh20200207\AppData\Roaming\Typora\typora-user-images\image-20210514105553548.png" alt="image-20210514105553548" style="zoom:50%;" />

注：

<img src="C:\Users\dyh20200207\AppData\Roaming\Typora\typora-user-images\image-20210514114058604.png" alt="image-20210514114058604" style="zoom:50%;" />

#### 多个参数的模板

eg：

`template <typename T0,typename T1> class A{`

`};`

`template <typename T0,typename T1>`

`void func(T0 a,T1 b){}`

## L10_模板与STL初步

### 命名空间

- 为了避免在大规模程序的设计中，以及在程序员使用各种各样的C++库时，标识符的命名发生冲突，标准C++引入了关键字namespace（命名空间），可以更好地控制标识符的作用域。

- 标准C++库（不包括标准C库）中所包含的所有内容（包括常量、变量、结构、类和函数等）都被定义在命名空间std（standard标准）中。

### 命名空间的定义与调用

定义命名空间：`namespace A { int x , y ;}`

使用命名空间：`A::x=3;A::y=2;`

1. 使用using声明简化命名空间使用
2. 使用整个命名空间：所有成员都直接可用 `using namespace A; x=3;y=6;`
3. 使用部分成员，所选成员可直接使用 `using A::x; x=3;A::y=6;`
4. 任何情况下，都不应出现命名冲突

### STL初步

关于命名空间：

1. STL的命名空间是std
2. ⼀般使用std::name来使用STL的函数或对象
3. 也可以使用using namespace std来引入STL的命名空间 **（不推荐在大型工程中使用，容易污染命名空间）**

#### pair

`template <class T1,classT2>`

`struct pair{` 

`T1 first; T2 second;` 

`//若干其它函数` 

`};`

- 通过first、second两个成员变量获取数据。

`std::pair<int,int> t;`

`t.first=4;t.second=5;`

- 创建：使用make_pair函数 **可自动推导成员类型**

`auto t = std::make_pair(“abc”, 7.8);`

支持大于小于比较：

1. 先比较first，后比较second
2. 要求成员类型支持比较(实现比较运算符重载)

#### tuple

pair的扩展，由若干成员组成的元组类型。

`template <class T1,classT2,class T3.....> class tuple;` 

- 通过std::get函数获取数据。

`v0 = std::get<0>(tuple1);` 

`v1 = std::get<1>(tuple2);`

注：

1. **`get<n>`是指返回传入元组的第n+1个数据**
2. 其下标需要在编译时确定：不能设定运行时可变的长度，**不能当做数组**

`int i = 0;` 

`v = std::get<i>(tuple); //编译错误`

- 创建：使用make_tuple函数

`auto t = std::make_tuple(“abc”, 7.8, 123, ‘3’);`

- 创建：使用tie函数，**返回左值引用的元组**

`std::string x; double y; int z;` 

`std::tie(x, y, z) = std::make_tuple(“abc”, 7.8, 123);`

 `//等价于 x = "abc"; y = 7.8; z = 123`

#### vector

会自动扩展容量的数组，以循序的方式维护变量集合

**<u>允许直接以下标访问</u>**

##### vector常用函数

1. 创建：`std:vector<int> x;`
2. 当前数组长度： `x.size()`
3. 清空： `x.clear();`
4. 在**末尾**添加/删除： `x.push_back(1); x.pop_back();`
5. （使用迭代器）在**中间**添加/删除： `x.insert(x.begin()+1, 5); x.erase(x.begin()+1);`<u>**比上一种函数执行速度慢**</u>

#### 迭代器

- ⼀种检查容器内元素并遍历元素的数据类型。
- 提供⼀种方法顺序访问⼀个聚合对象中各个元素, 而又不需暴露该对象的内部表示。
- **使用上类似指针**

##### 以vector为例

定义：`vector::iterator iter;`定义了⼀个名为iter的变量，它的数据类型是由vector定义的iterator类型

###### 常用函数

`x.begin()`，返回vector中第⼀个 元素的迭代器。

`x.end()`，返回vector中**<u>最后⼀个元素之后的位置</u>**的迭代器。

###### 迭代器的运算

下⼀个元素：`++iter`   `iter++`

下n个元素：`iter += n`

访问元素值： `*iter = 5;`

元素位置差：迭代器相减 `int dist = iter1 – iter2;`

###### 迭代器的算法

遍历vector：

`for(vector::iterator it = vec.begin();  it != vec.end(); ++it)`

也可使用auto代替：

`for(auto it = vec.begin(); it != vec.end(); ++it)`

也可与下方代码等价：

`for(auto x : vec)`

###### 迭代器失效

当迭代器不再指向本应指向的元素时，称此迭代器失效。

失效的情况：

1. 调用insert/erase后，所修改位置之后的所有迭代器失效。（原先的内存空间存储的元素被改变）
2. 调用push_back等修改vector大小的方法时，可能会使所有迭代器失效

#### list

定义：`std::list<int> l;`

常用函数：

1. `l.push_front(1);`//插入前端
2. `l.push_back(2);`//插入末端
3. `std::find(l.begin(), l.end(), 2); `//查询，返回迭代器
4. `l.insert(it, 4); `//插入指定位置，it为迭代器

性质：

1. 不支持下标等随机访问
2. 支持高速的在任意位置插入/删除数据
3. 其访问主要依赖迭代器
4. 插入和删除操作**不会导致迭代器失效**（除指向被删除的元素的迭代器外）

#### set

定义：`std::set<int> s;`

常用函数：

1. `s.insert(val);`//插入，**不允许出现重复元素**
2. `s.find(val);` //查询值为val的元素，返回迭代器
3. `s.erase(s.find(val));`//删除，**会导致迭代器失效**
4. `s.count(val);`//统计val的个数，返回值总是1或0；

性质：

1. **不重复元素**构成的**无序**集合
2. 内部**按大小顺序排列**，比较器由函数对象Compare完成。
3. 无序是指不保持插入顺序，容器内部排列顺序是根据元素大小排列

#### map

**<u>map常用作稀疏数组或以字符串为下标的数组。内部按照key的大小顺序排列</u>**

定义：`std::map<int,int> m;`

常用函数：

1. `s.find(key);`//查询键为key的元素，返回迭代器
2. `s.count(key);`//统计键为key的元素，返回值为0或1
3. `s.erase(s.find(key));`//删除元素，导致被删除元素的迭代器失效

性质：

1. 其值类型为pair
2. map中的元素**key必须互不相同**
3. 可以通过下标访问（**即使key不是整数**）。下标访问时如果元素不存在，则**创建对应元素**。
4. 可使用insert函数进行插入

eg：`std::map s; `

​        `s["Monday"] = 1; `

​        `s.insert(std::make_pair(std::string("Tuesday"), 2));`

#### 总结

- 序列容器：vector、list
- 关联容器：set、map
- 序列容器中的元素有顺序，可以按顺序访问。 
- 关联容器中的元素无顺序，可以按数值（大小）访问。
- vector中插入删除操作会使操作位置之后全部的迭代器失效。 其他容器中只有**被删除元素的迭代器失效**

## L11_复习及实用技巧

## L12_STL和字符串处理

### string字符串类

#### 常用函数

<img src="C:\Users\dyh20200207\AppData\Roaming\Typora\typora-user-images\image-20210521194139319.png" alt="image-20210521194139319" style="zoom:50%;" />

<img src="C:\Users\dyh20200207\AppData\Roaming\Typora\typora-user-images\image-20210521194211239.png" alt="image-20210521194211239" style="zoom:50%;" />

<img src="C:\Users\dyh20200207\AppData\Roaming\Typora\typora-user-images\image-20210521194232973.png" alt="image-20210521194232973" style="zoom:50%;" />

<img src="C:\Users\dyh20200207\AppData\Roaming\Typora\typora-user-images\image-20210521194246796.png" alt="image-20210521194246796" style="zoom:50%;" />

<img src="C:\Users\dyh20200207\AppData\Roaming\Typora\typora-user-images\image-20210521194306890.png" alt="image-20210521194306890" style="zoom:50%;" />

### iostream输入输出流

#### ostream与cout

- ostream即output stream,是STL库中所有输出流的基类
- 它重载了针对基础类型的输出流运算符（<<) 接受不同类型的数据，再调用系统函数进行输出
- 统一了输出接口，改善了C中输出方式混乱的状况
- cout是STL中内建的一个ostream对象,它会将数据送到标准输出流
- **<u>禁止复制、只允许移动；仅使用cout一个全局对象，故重载时返回值均为引用</u>**

#### 格式化输出

<img src="C:\Users\dyh20200207\AppData\Roaming\Typora\typora-user-images\image-20210521194542687.png" alt="image-20210521194542687" style="zoom:50%;" />

#### endl

endl是一个函数：等同于输出'\n'，再清空缓冲区 `os.flush()`

**写文件时，只有清空缓冲区或关闭文件才能保证内容正确写入**

#### 文件输入输出流（以输入流为例）

ifstream是istream的子类，功能是从文件中读入数据

##### 常用函数

<img src="C:\Users\dyh20200207\AppData\Roaming\Typora\typora-user-images\image-20210521195132688.png" alt="image-20210521195132688" style="zoom:50%;" />

<img src="C:\Users\dyh20200207\AppData\Roaming\Typora\typora-user-images\image-20210521195146270.png" alt="image-20210521195146270" style="zoom:50%;" />

#### 字符串输入输出流

- 它在对象内部维护了一个buffer
- 使用流输出函数可以将数据写入buffer
- 使用流输入函数可以从buffer中读出数据

构造方式：`stringstream ss;` //空字符串流 

​				   `stringstream ss(str);` //以字符串初始化流

### 字符串处理与正则表达式

正则表达式：由字母和符号组成的特殊文本，搜索文本时定义的一种规则

<img src="C:\Users\dyh20200207\AppData\Roaming\Typora\typora-user-images\image-20210522011244977.png" alt="image-20210522011244977" style="zoom:50%;" />

正则表达式的三种形式：

1. 匹配：判断整个字符串是否满足条件
2. 搜索：符合正则表达式的子串
3. 替换：按规则替换字符串的子串

#### 字符簇

1. 字符代表其本身  如：使用the进行搜索，可以找到句中所有的"the"
2. 匹配的单个字符在某个范围中  如：[a-z] 匹配所有单个小写字母
3. 连用  如：`[a-z][0-9]` 匹配所有字母+数字的组合，比如a1、b9
4. 或连接符 可使用`‘|’`作为连接符，表示或
5. 特殊字符

<img src="C:\Users\dyh20200207\AppData\Roaming\Typora\typora-user-images\image-20210522011822180.png" alt="image-20210522011822180" style="zoom:50%;" />

6. 重复模式

<img src="C:\Users\dyh20200207\AppData\Roaming\Typora\typora-user-images\image-20210522011954341.png" alt="image-20210522011954341" style="zoom:50%;" />

#### 正则表达式库`<regex>`

创建一个正则表达式对象

eg：`regex re("^[1-9][0-9]{10}$")` 11位数

注：**<u>C++的字符串中`"\"`也是转义字符；如果需要创建正则表达式"\d+"，应该写成`regex re("\\d+")`</u>**

#### 原生字符串

- 原生字符串可以取消转义，保留字面值
- 语法：`R"(str)"` 表示str的字面值，即`"\\d+" = R"(\d+)" = \d+`
- 原生字符串能换行，比如 `string str = R"(Hello换行符World)";`结果`str = "hello\nWorld"`

#### 正则表达式常用函数

##### 匹配

regex_match(s, re)

询问字符串s是否能**完全**匹配正则表达式re，返回值为bool类型

##### 捕获和分组

- 使用()进行标识，每个标识的内容被称作分组
- 正则表达式匹配后，每个分组的内容将被捕获，**可用于提取关键信息**

regex_match(s, result, re)

询问字符串s是否能完全匹配正则表达式re，并将捕获结果储存到result中

注：

- **result需要是smatch类型的对象，且smatch的对象可通过下标访问**
- **分组规则：按顺序标号，0号永远是匹配的字符串本身**
- eg：用`(sub)(.*)`匹配subject：0号为subject，1号为sub，2号为ject

##### 搜索

regex_search(s, result, re)

搜索字符串s中能够匹配正则表达式re的**第一个**子串，并将结果存储在result中

注：

- **result是一个smatch对象**
- **对于该子串，分组同样会被捕获**

##### 替换

regex_replace(s, re, s1)

替换字符串s中所有匹配正则表达式re的子串，并替换成s1

注：

- s1也可以使用一些特殊符号，代表捕获的分组
- $& 代表re匹配的子串；$1, $2 代表re匹配的第1/2个分组

## L13_函数对象和智能指针

### 函数对象

#### 函数指针

声明：<img src="C:\Users\dyh20200207\AppData\Roaming\Typora\typora-user-images\image-20210524154100822.png" alt="image-20210524154100822" style="zoom: 50%;" />

使用：

- 函数指针的类型较为复杂，可使用auto自动推断（**使用auto时必须要初始化**）
- `auto func = flag==1?increase:decrease; for (int &x : arr) { func(x);}`

#### 函数对象

STL提供了预定义的可比较大小的函数：

`sort(arr, arr+5, less<int>())`；`sort(arr, arr+5, greater<int>())`

其中：

- greater是一个模板类
- `greater<int>`是一个用int实例化的类
- `greater<int>（）`是该类的一个对象
- 同时，此对象具有函数的特征

<img src="C:\Users\dyh20200207\AppData\Roaming\Typora\typora-user-images\image-20210524155553690.png" alt="image-20210524155553690" style="zoom:50%;" />

因此，这种对象被称为函数对象

##### 函数对象的实现

- 需要重载operator()运算符：**<u>重载的operator()运算符中需要实现函数对应所需的功能</u>**
- 并且该函数需要是public访问权限

<img src="C:\Users\dyh20200207\AppData\Roaming\Typora\typora-user-images\image-20210524162434402.png" alt="image-20210524162434402" style="zoom:50%;" />

**<u>comp为Compare类型，在编译过程中编译器可自动推断类型，故即可接受函数指针，又可接受函数对象</u>**

**<u>上述实现需要有Greater类的实现和bool comp函数的实现</u>**

#### std::function类

<img src="C:\Users\dyh20200207\AppData\Roaming\Typora\typora-user-images\image-20210527171749627.png" alt="image-20210527171749627" style="zoom:50%;" />

#### 几种实现方式对比

1. 虚函数实现：

需要构造基类和子类；运行时确定调用函数的地址

2. 使用模板实现：

可以支持函数指针和函数对象（通过模板，自动重载实现）；编译期确定调用函数的地址

3. 使用std::function实现：

可以支持函数指针和函数对象 （通过function的多态）；运行时确定调用函数的地址

### 智能指针与引用计数

#### shared_ptr

1. 来自`<memory>`库
2. 构造方法：

`shared_ptr p1(new int(1));` 

`shared_ptr p2 = make_shared(2);` 

`shared_ptr p3 = p2;` 

`shared_ptr p4; //空指针`

3. 访问对象

`int x = *p1; //从指针访问对象` 

`int y = p2->val; //访问成员变量`

4. 销毁对象

**p2和p3指向同一对象，当两者均出作用域才会被销毁**

5. 其他用法

 `p.get()` 获取裸指针

`dynamic_pointer_cast(p)` 转为int类型指针(和dynamic_cast类似，动态类型检查）

`p.reset()` 重新指向新的空间，并将原有空间delete

#### 引用计数

通过辅助指针来判断目前该内存区域是否有指针指向，如辅助指针发现并无指针指向该区域，便会调用析构函数删除这一块内存。

## L14_行为型模式（OOP思想的集中体现）

### 设计模式

1. 遵循面向对象设计原则
2. 对接口编程而不是对实现编程（即提高代码复用，抽象通用接口）
3. 优先使用对象组合而不是继承（即降低模型复杂程度， 对功能尽可能划分）

设计模式的分类：

1. 行为型模式

关注对象行为功能上的抽象，从而提升对象在行为功能上的可拓展性，**能以最少的代码变动完成功能的增减**

2. 结构型模式

关注对象之间结构关系上的抽象，从而提升对象结构的可维护性、代码的健壮性，**能在结构层面上尽可能的解耦合**

3. 创建型模式

将对象的创建与使用进行划分，从而规避复杂对象创建带来的资源消耗，**能以简短的代码完成对象的高效创建**

### 行为型模式

#### 模板方法模式

一个例子：CPU监视器

1. 简单枚举的实现方式

   ```cpp
   class Monitor
   {
   public:
       void getLoad();
       void getTotalMemory();
       void getUsedMemory();
       void getNetworkLatency();
       Monitor(Display *display);
       virtual ~Monitor();
       void show();
   private:
       float load, latency;
       long totalMemory, usedMemory;
       Display *m_display;
   };
   // 组合一个 Display 接口来进行结果展示
   void Monitor::show()
   {
       m->display -> show(load, totalMemory, usedMemory, latency);
   }
   //规定所有的系统类型
   enum MonitorType {Win32, Win64, Ganglia};
   MonitorType type = Ganglia;
   …
   //获取负载信息的实现
   void Monitor::getLoad()
   {
       switch (type)
       {
           //Win32 版本的信息获取
           case Win32: 
               load = …;
           //Win64 版本的信息获取
           case Win64:
               load = …;
           //Ganglia 版本的信息获取
           case Ganglia:
               load = …;
       }
   }
   // 其他实现
   //主程序
   int main(int argc, char *argv[])
   {
       WindowsDisplay display;
       Monitor monitor(&display);
       while (running())
       {
           //获取负载信息
           monitor.getLoad();
           //获取内存大小信息
           monitor.getTotalMemory();
           //获取内存使用信息
           monitor.getUsedMemory();
           //获取网络延迟信息
           monitor.getNetworkLatency();
           //信息输出
           monitor.show();
           sleep(1000);
       }
       return 0;
   }
   ```



**<u>可以发现，每新增一个系统，都需要对每个方法进行相应修改，修改的工作量极大。</u>**

2. 模板方法

在接口的一个方法中定义算法的骨架，将一些步骤的实现延迟到子类中，使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。

**核心观念：**

<img src="C:\Users\dyh20200207\AppData\Roaming\Typora\typora-user-images\image-20210531152853326.png" alt="image-20210531152853326" style="zoom:50%;" />

具体实现：

<img src="C:\Users\dyh20200207\AppData\Roaming\Typora\typora-user-images\image-20210531152921445.png" alt="image-20210531152921445" style="zoom:50%;" />

基类Monitor代码实现：

```cpp
class Monitor
{
public:
    virtual void getLoad() = 0;
    virtual void getTotalMemory() = 0;
    virtual void getUsedMemory() = 0;
    virtual void getNetworkLatency() = 0;
    Monitor(Display *display);
    virtual ~Monitor();
    void show();
protected:
//用以存储信息的成员变量
    float load, latency;
    long totalMemory, usedMemory;
    Display* m_display;
};

//组合一个Display接口来进行结果展示
void Monitor::show()
{
    m_display -> show(load, totalMemory, usedMemory, latency);
} 
```

`MonotorWin32` 实现：

```cpp
//通过具体实现抽象的模板来完成Win32系统下的监控器实现
class MonitorWin32::public Monitor
{
public:
    void getLoad();
    void getTotalMemory();
    void getUsedMemory();
    void getNetworkLatency();
};
//Win32的getLoad()的具体实现
void MonitorWin32::getLoad()
{
    //…
    load = …;
    //…
}
//Win32的getTotalMemory()的具体实现
void MonitorWin32::getTotalMemory() {
    //…
    totalMemory = …;
    //…
}
//…
```

主程序实现：

```cpp
int main(int argc, char *argv[])
{
    WindowsDisplay display;
    //创建MonitorWin32模式的监控器，并用基类指针来调用方法
    Monitor* monitor = new MonitorWin32(&display);
    while (running())
    {
        monitor->getLoad();
        //获取负载信息
        monitor->getTotalMemory();
        //获取内存大小信息
        monitor->getUsedMemory();
        //获取内存使用信息
        monitor->getNetworkLatency();
        //获取网络延迟信息
        monitor->show();
        //信息输出
        sleep(1000);
    }
    //释放
    delete monitor;
    return 0;
}
```

##### 特点：

1. ###### 针对接口编程

   模板方法其实就是一种针对接口编程的设计。

   通过抽象出**抽象概念**，设计出描述这个抽象概念的抽象类，或称为**接口类**（`Monitor`），这个类有一系列的（纯）虚函数，描述了这个类的接口。

   对这个类的接口类进行继承并实现这些（纯）虚函数，从而形成这个抽象概念的**实现类**（`MonotorWin32` ）——实现可以有多种。

   在使用此概念时，**使用接口类**（`Monitor*`）来引用这个概念，而不直接使用实现类，从而避免类的改变造成整个程序的大规模变化。

2. ###### 开放封闭原则

   模板方法很好地体现了开放封闭原则：

   - 对扩展开放，有新需求或变化时，可以方便地对现有代码进行拓展，而无需整体变动。

   - 对修改封闭，新的拓展类一旦设计完成，可以独立完成其工作，同样不需要整体变动。

   开放封闭原则的核心就是在**结构层面**上解耦合，对抽象进行编程，而不对具体编程。

   - 抽象结构是简单与稳定的。
   - 具体实现是复杂与多变的。

#### 策略模式

如果 `getLoad()` 等几种函数的接口实现方法互为独立，假设各自有 n,m,kn,m,k 种实现方法，则需要实现 n×m×kn×m×k 个子类！

这种大量冗余实现看着就很不可取。

策略模式，即定义一系列算法并加以封装，使得这些算法可以互相替换。**核心思想是实现功能上的分离！！！**

<img src="C:\Users\dyh20200207\AppData\Roaming\Typora\typora-user-images\image-20210531153449528.png" alt="image-20210531153449528" style="zoom:50%;" />

<img src="C:\Users\dyh20200207\AppData\Roaming\Typora\typora-user-images\image-20210531153503671.png" alt="image-20210531153503671" style="zoom:50%;" />

具体实现：

Monitor的实现：

```cpp
class Monitor // 监控器类
{
public:
    // 监控器就是各个策略类的组合
    Monitor(LoadStrategy *loadStrategy,
           MemoryStrategy *memStrategy,
           LatencyStrategy *latencyStrategy
           Display *display);
    void getLoad();
    void getTotalMemory();
    void getUsedMemory();
    void getNetworkLatency();
    void show();
private:
    // 获取各类不同信息的策略类
    LoadStrategy *m_loadStrategy;
    MemoryStrategy *m_memStrategy;
    LatencyStrategy *m_latencyStrategy;
    // 用以存储信息的成员变量
    float load, latency;
    long totalMemory, usedMemory;
    Display *m_display;
};
// 构造函数初始化所有的策略和参数
Monitor::Monitor(LoadStrategy *loadStrategy,
                 MemoryStrategy *memStrategy,
                 LatencyStrategy *latencyStrategy
                 Display *display) :
                 m_loadStrategy(loadStrategy),
                 m_memStrategy(memStrategy),
                 m_latencyStrategy(latencyStrategy),
                 m_display(display),        
                 load(0.0), latency(0.0), 
                 totalMemory(0), usedMemory(0) {}

// 统一的输出接口输出不同策略类获得的系统信息
void Monitor::show()
{
    m_display -> show(load, totalMemory, usedMemory, latency);
}
// 统一的接口来获取负载
void Monitor::getLoad()
{
    load = m_loadStrategy -> getLoad();
}
// 统一的接口来获取总内存
void Monitor::getTotalMemory()
{
    totalMemory = m_memStrategy -> getTotal();
}
// 统一的接口来获取已用内存
void Monitor::getUsedMemory()
{
    usedMemory = m_memStrategy -> getUsed();
}
// 统一的接口来获取网络延迟信息
void Monitor::getNetworkLatency()
{
    latency = m_latencyStrategy -> getLatency();
}
```

部分功能的实现（以`LoadStrategy`为例）：

```cpp
class LoadStrategy // 负载策略基类
{                               
public:
    virtual float getLoad() = 0;
};
// 负载算法一具体实现
class LoadStrategyImpl1 : public LoadStrategy
{   
public:
    float getLoad() // 获取负载数值
    {
        //…
        return load;
    }
};
//负载算法二具体实现
class LoadStrategyImpl2 : public LoadStrategy
{   
public:
    float getLoad() // 获取负载数值
    {
        //…
        return load;
    }
};
```

同理也可以类似实现 `MemoryStrategy` 和 `Latencystrategy`

主程序实现：

```cpp
int main(int argc, char *argv[])
{
    // 为每个策略的选择具体的实现算法，并创建监控器类
    GangliaLoadStrategy loadStrategy;
    WinMemoryStrategy   memoryStrategy;
    PingLatencyStrategy latencyStrategy;
    WindowsDisplay      display;
    //具体构建过程是将每个策略的具体算法类传入构造函数
    Monitor monitor(&loadStrategy, &memoryStrategy, &latencyStrategy, &display);
    while (running()) {
        // 统一的接口获取系统信息
        monitor.getLoad();
        monitor.getTotalMemory();
        monitor.getUsedMemory();
        monitor.getNetworkLatency();
        // 统一的接口输出系统信息
        monitor.show();
        sleep(1000);
    }
    return 0;
}
```

**<u>在这样的情况下，如果同样还各有 n+m+kn+m+k 种实现，我们只需要实现 n+m+k+3n+m+k+3 个新类</u>**

##### 特点：

1. ###### 单一责任原则

   策略模式很好的体现了单一责任原则：

   - 一个类（接口）只负责一项职责。
   - 不要存在多于一个导致类变更的原因。

   如果一个类承担的职责过多，职责之间的耦合度会很大。

   - 职责的变化可能会削弱或抑制这个类完成其他职责的能力。
   - 多变的场景会使得整体程序遭受破坏，维护难度增大。

   单一责任原则的核心就是在**功能层面**上解耦合。（对比：之前是结构层面）

#### 模板模式与策略模式的对比

当我们需要实现一个新的 `getTotalMemory` 和 `getUsedMemory()`，模板方法理论上需要实现新子类 n×mn×m 个，而策略模式则只需 11 个。

可以看出两者的一大区别就是，前者注重**继承（功能的抽象与归纳）**，后者注重**组合（功能的划分与组合）**。

**前者优点：**

- 基类高度抽象统一，逻辑简洁明了。
- 子类之间关联不紧密时易于简单快速实现。
- 封装性好，实现类内部不会对外暴露。

**缺点：**

- 接口同时负责所有功能。
- 任何算法修改会导致整个实现类的变化（重实现）。

**后者优点：**

- 每个策略只负责一个功能，易于拓展。
- 算法的修改被限制在单个策略类的变化中，任何算法的修改对整体不造成影响。

**缺点：**

- 在功能较多的情况下结构复杂。
- 策略组合时对外暴露，封装性相对较差。

这两种模式实际上都是解决算法多样性对代码结构冲击的问题。

当业务相对简单时，两者几乎等效。

模板方法更侧重于**逻辑复杂但结构稳定**的场景，尤其是**某些步骤（功能）变化剧烈且无相互关联**。

策略模式则适用于**算法（功能）本身灵活多变**的场景，且**多种算法之间需要协同工作**。

#### 迭代器模式

一个例子：对考试结果的分析（及格率）

```cpp
int main(int argc, char *argv[])
{
    float scores[STUDENT_COUNT];
    int passed = 0;

    for (int i = 0; i != STUDENT_COUNT; i++)
    {
        if (scores[i] >= 60) 
            passed ++;
    }

    cout << "passing rate = "
         << (float)passed / STUDENT_COUNT
         << endl;

    return EXIT_SUCCESS;
}
```

把分析单独作为一个功能：

```cpp
void analyze(float *scores, int student_count)
{
    int passed = 0;

    for (int i = 0; i != student_count; i++)
    {
        if (scores[i] >= 60) 
            passed ++;
    }

    cout << "passing rate = "
         << (float)passed / student_count
         << endl;
}
```

但如果成绩不是用数组存储而是单向非循环链表呢？

```cpp
struct Student
{
    float score;
    Student *next;
};

//...

Student *head;
```

此时分析就需要修改为：

```cpp
void analyze(Student *head)
{
    int passed = 0, count = 0;

    for (Student *p = head; p != NULL; p = p -> next) {
        if (p -> score >= 60) 
            passed ++;
        count ++;
    }

    cout << "passing rate = "
         << (float)passed / count
         << endl;
}
```

存在的问题：

如何实现**与底层数据结构无关**的统一算法接口？

变与不变：

- 需要遍历所有学生的成绩，即算法不变。
- 不希望绑定在某种存储方式，即底层数据结构是变化的。

解决方案：

可以考虑分离**存储的变**与**访问的不变**：

- 把数据访问设计为一个接口。
- 针对不同的存储完成这个接口的不同实现

##### 迭代器模式

提供一种方法顺序访问一个聚合对象中各个元素。

又不需暴露该对象的内部表示——与对象的内部数据结构形式无关。

具体实现相当于模板方法构建迭代器和数据存储基类，为每种单独数据结构实现独有的迭代器和存储类。

但对于上层算法，算法的执行只依赖于抽象的迭代器接口，而无需关注最底层的具体数据结构。

<img src="C:\Users\dyh20200207\AppData\Roaming\Typora\typora-user-images\image-20210531154830316.png" alt="image-20210531154830316" style="zoom:50%;" />

迭代器基类Iterator的实现：

迭代器模式中，存在迭代器 `Iterator` 和数据存储器 `Collection` 两部分。

针对每种数据存储结构，通过继承实现相应存储类 `CollectionImplementation` 及迭代器类 `IteratorImplementation`。

迭代器类是存储类的友元，从而**迭代器类可以访问存储器类内部的数据**。

这个迭代器可以套接在任意的数据结构上。

```cpp
//迭代器基类
class Iterator
{
public:
    virtual ~Iterator() {}
    virtual Iterator& operator++() = 0;
    virtual float& operator++(int) = 0;
    virtual float& operator*() = 0;
    virtual float* operator->() = 0;
    virtual bool operator!=(const Iterator &other) const = 0;
    bool operator==(const Iterator &other) const
    {
        return !(*this != other);
    }
};
```

使用迭代器：

用迭代器作为参数传递参与上层算法构建：

```cpp
void analyze(Iterator* begin, Iterator* end)
{
    int passed = 0, count = 0;

    for (Iterator* p = begin; *p != *end; (*p)++)
    {
        if (**p >= 60) 
            passed ++;
        count ++;
    }

    cout << "passing rate ="
         << (float)passed / count
         << endl;
}
```

实现 `Collection` 基类：

定义数据存储结构基类 `Collection`，需要给存储对象一个约束：

- 能够返回代表头和尾的迭代器。
- 使用左闭右开区间，即 [begin,end)

```cpp
class Collection
{
public:
    virtual ~Collection() {}
    virtual Iterator *begin() const = 0;
    virtual Iterator *end() const = 0;
    virtual int size() = 0;
};
```

实现基于数组的 `Collection`：

```cpp
class ArrayCollection : public Collection // 底层为数组的存储结构类
{
    friend class ArrayIterator; // friend 可以使得配套的迭代器类可以访问数据
    float* _data;
    int _size;
public:
    ArrayCollection() : _size(10)
    {
        _data = new float[_size];
    }
    ArrayCollection(int size, float* data) : _size(size)
    {
        _data = new float[_size]; // 开辟数组空间用以存储数据
        for (int i = 0; i < size; i++) 
            *(_data+i) = *(data+i);  
    }
    ~ArrayCollection()
    {
        delete[] _data;
    }
    int size()
    {
        return _size;
    }
    Iterator* begin() const;
    Iterator* end() const;
};
Iterator* ArrayCollection::begin() const // 头迭代器，并放入相应数据
{
    return new ArrayIterator(_data, 0); 
}
Iterator* ArrayCollection::end() const // 尾迭代器，并放入相应数据
{
    return new ArrayIterator(_data, _size); 
}
```

实现基于数组的 `Iterator`：

```cpp
class ArrayIterator : public Iterator // 继承自迭代器基类并配套 ArrayCollection 使用的迭代器
{
    float *_data; // ArrayCollection 的数据
    int _index; // 数据访问到的下标
public:
    ArrayIterator(float* data, int index) :
        _data(data), _index(index) {}
    ArrayIterator(const ArrayIterator& other) : 
        _data(other._data), _index(other._index) {}
    ~ArrayIterator() {}
    Iterator& operator++();
    float& operator++(int);
    float& operator*();
    float* operator->();
    bool operator!=(const Iterator &other) const;
}; 
// 迭代器各种内容的实现
Iterator& ArrayIterator::operator++()
{
    _index++;
    return *this; 
}
// 因为是数组，所以直接将空间指针位置 +1 即可，可以思考下这里为什么返回 float&，而不是 Iterator
float& ArrayIterator::operator++(int)
{ 
    _index++; 
    return _data[_index - 1]; 
}
// 对 data 的内存位置取值
float& ArrayIterator::operator*()
{
    return *(_data + _index); 
}
float* ArrayIterator::operator->()
{
    return (_data + _index);
}
// 判断是不是指向内存的同一位置
bool ArrayIterator::operator!=(const Iterator &other) const
{
    return (_data != ((ArrayIterator*)(&other))->_data || _index != ((ArrayIterator*)(&other))->_index); 
}
```

**注**：在标准 STL 实现中 `operator++(int)` 的返回类型应该是一个 `iterator` 对象，如 `ArrayIterator ArrayIterator::operator++(int)` 的形式，但在这里迭代器模式的基类 `Iterator` 是抽象类，无法作为返回类型。

主程序可以是：

```cpp
int main(int argc, char *argv[])
{
    float scores[]={90, 20, 40, 40, 30, 60, 70, 30, 90, 100};   
    Collection *collection = new ArrayCollection(10, scores); 
    analyze(collection -> begin(), collection -> end());

    return 0;
}
```

##### 特点：

**<u>迭代器模式实现了算法和数据结构的隔离，规避了为每一个算法和数据结构的组合均进行代码实现的巨大工作量。</u>**

### 小结

行为型设计模式关系对象之间的行为功能抽象，核心在于抽象行为功能中不变的成分，具体实现行为功能中变的成分，保证以尽可能少的代码改动完成功能的增减。

- 模板方法归纳了一系列类的通用功能，在基类中将功能的接口固定，在子类中具体实现流程细节，使得新类的增加不影响原有类。
- 策略模式抽象了功能的选择与组合，隔离不同功能使其相互之间不受影响，可灵活支持算法、策略的修改。
- 迭代器模式抽象了数据访问方法，可以访问对象的元素但却不暴露底层实现，隔离具体算法与数据结构，在 STL 的算法、容器与迭代器中有非常多的应用。

## L15_结构型模式

### 适配器（Adapter）模式

#### 需求：栈

需要设计一个数据结构，满足**后进先出**。

![13](https://wzf2000.top/wordpress/wp-content/uploads/2020/07/13.png)

基本操作包括：

- `bool empty()`：判断是否为空。
- `void push(int)`：压入一个元素。
- `void pop()`：弹出栈顶元素。
- `int size()`：获取栈内元素数。
- `int top()`：获取栈顶元素。

利用数组可以较为容易实现，但这样的工作量较大，且自行管理内存容易出问题。

考虑到 STL 中的 `vector` 容器，可以对其进行**改造**。

#### 改造 `vector`

`vector` 的方法（接口）与栈要求的不同，但实际功能实际上均可以实现。

也就是需要转换接口。

#### 适配器

简单来说就是将已有类的接口转换成客户希望的另一种接口，使得类获得统一环境下的兼容性。

其结构包括：

- **目标（Target）**：客户所期待的接口。
- **需要适配的类（Adaptee）**：需要适配的类。
- **适配器（Adapter）**：通过包装一个需要适配的类，把原接口转换成目标接口。

### 对象适配器模式

![14](https://wzf2000.top/wordpress/wp-content/uploads/2020/07/14.png)

使用组合实现适配，称为对象适配器模式。

此处 `Adapter` 类与 `Adaptee` 类之间的关系是一种比较强关联。

#### 适配器基类（目标类）

![15](https://wzf2000.top/wordpress/wp-content/uploads/2020/07/15.png)

```cpp
class Stack
{
public:
    virtual ~Stack() {}
    virtual bool full() = 0;
    virtual bool empty() = 0;
    virtual void push(int i) = 0;
    virtual void pop() = 0;
    virtual int size() = 0;
    virtual int top() = 0;
};
```

C++

Copy

#### 适配器实现

```cpp
class Vector2Stack : public Stack
{
    std::vector<int> m_data;
    const int m_size;
public:
    Vector2Stack(int size) : m_size(size) {}
    bool full()
    {
        return (int)m_data.size() >= m_size;
    }
    bool empty()
    {
        return (int)m_data.size() == 0;
    }
    void push(int i)
    {
        m_data.push_back(i);
    }
    void pop()
    {
        if (!empty()) m_data.pop_back();
    }
    int size()
    {
        return m_data.size();
    }
    int top()
    {
        if (!empty())
            return m_data[m_data.size() - 1];
        else
            return INT_MIN;
    }
};
```

C++

Copy

### 类适配器模式

![16](https://wzf2000.top/wordpress/wp-content/uploads/2020/07/16.png)

使用继承实现适配，称作类适配器模式。

#### 适配器基类（目标类）

与对象适配器模式完全相同。

#### 适配器实现

```cpp
class Vector2Stack : private std::vector<int>, public Stack
{
public:
    Vector2Stack(int size) : vector<int>(size) {}
    bool full()
    {
        return false;
    }
    bool empty()
    {
        return vector<int>::empty();
    }
    void push(int i)
    {
        push_back(i);
    }
    void pop()
    {
        pop_back();
    }
    int size()
    {
        return vector<int>::size();
    }
    int top()
    {
        return back();
    }
};
```

C++

Copy

### 适配器

#### 优点

- 通过适配器，可统一复杂的底层接口。
- 复用现有类。
- 引入适配器类，使得原有代码无需修改。

#### 使用场景

- 需要复用已有类，然而原有接口不符合要求。
- 接口第三方组件，接口不符合要求。
- 旧类（无法修改）实现的功能需要用新接口访问。

实际上，STL 中的**智能指针**就是典型的适配器。

但是单纯的接口转换做不到计数控制，因此还需要别的设计模式。

### 代理/委托（Proxy）模式

#### 需求

一些应用中，无法直接访问对象：

- 要访问对象在远程机器上。
- 被访问对象创建的开销大。
- 某些操作需要安全控制。
- 需要进程外的访问。
- 直接访问会带来麻烦。
- 对象需要根据访问者行为作出复杂处理。

在这种情况下，我们可在访问对象上加一个访问层，使得复杂操作在内部不对外开放，但功能接口开放。

这也就是**代理/委托模式**。

#### 场景

**远程代理**：

- 实际应用中，常需要从其它进程或者远程地址获取资源，而这个过程耗时较长或难以直接完成，此时可利用代理/委托模式。
- 利用这种方式替换原有获取方式，可以更高效、安全。

**资源安全**：

- 多进程编程中，并非所有进程都对所有资源拥有访问使用修改的权限，所以进程调用中，我们可以使用这种模式检查当前进程对当前资源是由拥有权限。

```cpp
void Proxy::request()
{
    if (checkAuthority(nowProcess, nowResource))
    {
        // do something...
    }
}
```

C++

Copy

#### 代理/委托

![17](https://wzf2000.top/wordpress/wp-content/uploads/2020/07/17.png)

其中横线是相互关联，相互之间有使用或者定义。

`RealSubject` 是实质功能完成者，`Proxy` 是代理人，来包装 `RealSubject`，对外提供接口，也负责除了 `RealSubject` 自身功能以外的各种功能，比如前面提到的引用计数。

#### 实例：智能指针引用计数

```cpp
#include <iostream>
using namespace std;

template <typename T>
class SmartPtr;

template <typename T>
class U_Ptr
{
    int count;
    T *p;

    friend class SmartPtr<T>;

    U_Ptr(T *ptr) : p(ptr), count(1) {}
    ~U_Ptr()
    {
        delete p;
    }
};

template <typename T>
class SmartPtr
{
    U_Ptr<T> *rp;
public:
    SmartPtr(T *ptr) : rp(new U_Ptr<T>(ptr)) {}
    SmartPtr(const SmartPtr<T> &sp) : rp(sp.rp)
    {
        ++rp->count;
    }
    SmartPtr& operator=(const SmartPtr<T> &rhs)
    {
        ++rhs.rp->count;
        if (--rp->count == 0) delete rp;
        rp = rhs.rp;
        return *this;
    }
    ~SmartPtr()
    {
        if (--rp->count == 0) delete rp;
    }
    // 对智能指针操作等同于对内部辅助指针操作
    T& operator*()
    {
        return *(rp->p);
    }
    T* operator->()
    {
        return rp->p;
    }
};

int main()
{
    int *i = new int(2);
    SmartPtr<int> ptr1(i);
    SmartPtr<int> ptr2(ptr1);
    SmartPtr<int> ptr3 = ptr2;
    cout << *ptr1 << endl;
    *ptr1 = 20;
    cout << *ptr2 << endl;
    return 0;
}
// 结果为：
// 2
// 20
```

C++

Copy

#### 变与不变

- ```
  SmartPtr<int>
  ```

   

  与

   

  ```
  int*
  ```

   

  有相同的接口。

  - 操作符：`*` 和 `->`。
  - 赋值操作符与初始化（拷贝构造）。
  - 释放（析构）。

- ```
  SmartPtr<int>
  ```

   

  比

   

  ```
  int*
  ```

   

  增加了一些控制操作。

  - 增加了引用计数相关部分。

- 常被称为

  代理模式

  。

  - 接口不变，功能变化。
  - 用于对被代理对象进行控制，这里包括引用计数、权限控制、远程代理、延迟初始化等。
  - 代理类一方面提供被代理类所有接口，另一方面同时可进行额外控制操作。

#### 代理/委托与适配器

**相似**：

- 均为在被访问对象之上进行封装。
- 均提供被封装对象的功能接口供外部使用。

**不同**：

- 代理不会改变接口，但适配器可能会。
- 代理不会改变功能，但适配器可能会。
- 适配器不会增加控制，但代理可能会。
- **适配器的核心元素时变换接口，代理的核心要素是分割访问对象与被访问对象以减少耦合，并能在中间增加各种控制功能。**

### 装饰器（Decorator）模式

#### 实例

有一个对象 `TextView`，在窗口中显示文本。

希望接口不改变的情况下，增加滚动条、边框等。

#### 分析：继承

![18](https://wzf2000.top/wordpress/wp-content/uploads/2020/07/18.png)

使用继承，通过多态实现功能变化。

但同样会有问题：

- 随功能变多，继承类的数量急剧膨胀，其最大派生类的数目可以是所有功能的组合数。
- 如果 `TextView` 的基类增加新的接口，则所有派生类均需要修改。

#### 分析：策略模式

![19](https://wzf2000.top/wordpress/wp-content/uploads/2020/07/19.png)

如果用组合替代继承，也会有问题：

- 策略个数是基类中预先定义好的，比如基类中定义了边框和滑动条，则策略模式只能实现这两者。
- 如果需要增加一个新功能，则需要修改基类，增加策略个数和新方法，就会对整体框架进行改动。

#### 装饰器

![20](https://wzf2000.top/wordpress/wp-content/uploads/2020/07/20.png)

创建一个装饰类，用来包装原有类，并在保持类方法完整性的前提下，提供额外功能。

且装饰类与被包装类继承于同一个基类，这样只需要利用基类指针即可再次包装并增加更多功能。

#### 代码实现

```cpp
#include <iostream>
using namespace std;

class Component
{
public:
    virtual ~Component() {}
    virtual void draw() = 0;
};

class TextView : public Component
{
public:
    void draw()
    {
        cout << "TextView." << endl;
    }
};

class Decorator : public Component
{
    Component *_component;
public:
    Decorator(Component* component) : _component(component) {}
    virtual void addon() = 0;
    void draw()
    {
        addon();
        _component -> draw();
    }
};

class Border : public Decorator
{
public:
    Border(Component* component) : Decorator(component) {}
    void addon()
    {
        cout << "Bordered ";
    }
};

class HScroll : public Decorator
{
public:
    HScroll(Component* component): Decorator(component) {}
    void addon()
    {
        cout << "HScrolled ";
    }
};

class VScroll : public Decorator
{
public:
    VScroll(Component* component): Decorator(component) {}
    void addon()
    {
        cout << "VScrolled ";
    }
};

int main()
{
    TextView testView;
    VScroll vs_TextView(&testView);
    HScroll hs_vs_TextView(&vs_TextView);
    Border b_hs_vs_TextView(&hs_vs_TextView);
    b_hs_vs_TextView.draw();
    return 0;
}
// 结果：
// Bordered HScrolled VScrolled TextView
```

C++

Copy

#### 分析

整个过程是一个链式的调用关系。

每个对象都不需要了解整个链的全貌。

每次都是将之前的版本完全包裹住，再增加新功能。

也就是几个新功能就包了几层。

#### 装饰器与策略

**相同**：

- 通过对象组合修改对象的功能。
- 以组合替代简单继承，更加灵活，减少冗余。

**不同**：

- 策略模式修改对象功能的内核（行为），装饰器模式修改对象功能的外壳（结构）。
- 策略模式中组间必须了解有哪些需要选择的策略，侧重于功能选择，而装饰器模式中组件则无需了解，侧重于功能组装。

#### 装饰器与代理

都用于改变对象的行为，可以把装饰看为一连串的代理。

装饰常用多重嵌套，而代理较少见。

### 总结

结构型设计模式关心对象组成结构上的抽象，包括接口、层次、对象组合等。

核心在**抽象结构层次上的不变**，尽可能**减少类与类之间的联系与耦合**，从而能够以最小代价支持**新功能增加**。

## L16_创建型模式*

### 单例（Singleton）模式

#### 需求：全局计数器

设计一个全局计数器，程序任意位置调用 `addCount()` 均可以使得计数器 +1+1。

调用 `getCount()` 返回计数器数值。

如何实现这两个需求。

#### 分析：全局变量

```cpp
int count = 0;
void addCount()
{
    count++;
}
int getCount()
{
    return count;
}
```

C++

Copy

但这样的设计，用户容易访问到 `count` 变量使得其存在被随意修改的可能。

并且，我们最好应该避免全局变量。

#### 分析：静态成员

```cpp
class Counter
{
    static int count = 0;
public:
    void addCount()
    {
        count++;
    }
    int getCount()
    {
        return count;
    }
};

Counter counter;
counter.addCount();
cout << counter.getCount() << endl;
```

C++

Copy

如此实例化的方式显然很麻烦。

#### 分析：静态方法

```cpp
class Counter
{
    static int count = 0;
public:
    static void addCount()
    {
        count++;
    }
    static int getCount()
    {
        return count;
    }
};

Counter::addCount();
cout << Counter::getCount() << endl;
```

C++

Copy

这样似乎很完美。

#### 新需求：多种计数器

如果我们需要有多种 `Counter`，那么很容易想到利用虚函数和继承的方法实现。

也就是说会出现：

```cpp
class BaseCounter
{
public:
    static virtual void addCount() = 0;
    static virtual int getCount() = 0;
};
```

C++

Copy

但这样是会**编译错误**的！

换句话说，**静态方法加上虚函数**是**不可行**的！

静态方法不可以是虚函数！

#### 分析：根本目的

我们想要使用静态方法的根本目的在于：

- 无论何处调用，访问的是**相同的函数和变量**。
- **无需多次实例化**。

#### 单例模式

单例模式要求：

- 单例类只能有一个实例。
- 单例类必须自主创建唯一实例。
- 单例类必须可以提供这一唯一实例。

实现关键：

- **构造函数**不开放（`private`）。
- 通过**静态方法**、枚举返回单例类对象。

#### 实现：本类作为静态成员

```cpp
class Counter
{
    Counter(const Counter &) = delete;
    void operator=(const Counter &) = delete;

    int count;
    Counter()
    {
        count = 0;
    }
    static Counter _instance; // 全局唯一实例
public:
    static Counter &instance() // 唯一方法获取实例
    {
        return _instance;
    }
    void addCount()
    {
        count++;
    }
    int getCount()
    {
        return count;
    }
};
Counter Counter::_instance;
```

C++

Copy

使用时只须：

```cpp
Counter &c = Counter::instance();
c.addCount();
cout << c.getCount() << endl;
```

C++

Copy

单例模式封装了全局性变量，只有一次实例化，也没有依赖静态访问方法，满足上面的需求。

#### 优化：惰性初始化（Lazy Initialization）

我们希望单例模式在使用时自动构造单例实例。

只须将 `_instance` 这个成员改为：

```cpp
static Counter &instance()
{
    static Counter _instance;
    return _instance;
}
```

C++

Copy

这样，函数内静态变量在第一次执行到其定义时才会被构造。

也就是说，第一次调用 `instance()` 才会实例化单例。

**注**：这是考虑到一些较为复杂的类可能需要长时间构造，程序刚开始就构造可能导致程序卡顿之类问题。

#### 问题：意外删除

上面的实现保证了实例不会被重复构造，但实际上不能避免意外删除。

考虑下面代码：

```cpp
Counter &c = Counter::instance();
delete &c; // 可以执行
c.addCount(); // 运行时错误
```

C++

Copy

（引用和实例有着同样的实际地址）

所以还应该将**析构函数也设置为私有**。

#### 实现：单例模式 ++ 虚函数

```cpp
#include <iostream>

using namespace std;

class BaseCounter
{
public:
    virtual void addCount() = 0;
    virtual int getCount() = 0;
};

class SimpleCounter : public BaseCounter
{
    // ...单例相关逻辑...
    int count;
    SimpleCounter()
    {
        count = 0;
    }
public:
    virtual void addCount()
    {
        count++;
    }
    virtual int getCount()
    {
        return count;
    }
};

class NotSimpleCounter : public BaseCounter
{
    // ...相关逻辑
}

void doStuff(BaseCounter *counter)
{
    counter->addCount();
    cout << counter->getCount() << endl;
}

int main()
{
    doStuff(&SimpleCounter::instance());
    doStuff(&NotSimpleCounter::instance());
    doStuff(&SimpleCounter::instance());
    return 0;
}
```

C++

Copy

尚存在**缺陷**：

- 单例相关逻辑较多，需要在派生类中分别实现单例代码，尤其是每个单例派生类的 `instance()`。

#### 奇特的递归模板模式（CRTP）

全称为 **Curiously Recurring Template Pattern**。

```cpp
template <class Derived> // 模板参数为派生类类型
class Singleton
{
    Singleton(const Singleton &) = delete;
    void operator=(const Singleton &) = delete;
protected:
    Singleton() {}
    virtual ~Singleton() {}
public:
    static Derived &instance() // 关键部分
    {
        static Derived _instance;
        return _instance;
    }
};

class SimpleCounter : public BaseCounter, public Singleton<SimpleCounter>
{
    friend class Singleton<SimpleCounter>; // 友元声明使得 Singleton 类可以访问其私有的构造函数
    // ...只须实现计数器逻辑
};
```

C++

Copy

这里采用的是 **CRTP 加上多重继承**。

注意，不可将 `Singleton` 类的实现逻辑实现在 `BaseCounter` 类中，单例功能与其他功能剥离。

否则 `BaseCounter` 将成为模板类，无法脱离模板参数存在。

#### 代码合法原因

- 尽管 `Singleton` 利用到了 `SimpleCounter`，但其中不直接、间接包含 `SimpleCounter` 类，其大小不依赖于 `SimpleCounter`，所以实际上不需要其完整定义。
- 在模板类 `Singleton` 被实例化时，`SimpleCounter` 类与 `Singleton` 类的定义实际上已经给出。

#### 关于 CRTP

**CRTP** 是实现多台的另一种方式，实际上并不只是单例模式才会使用到：

- 利用 C++ 模板，让编译器生成重复代码。

其本质上还是编译器多态（静态多态）：

- 在编译期确定实际被调用的函数。

#### 关于单例模式

存在着一定争议。

**优点**：

- 实现似乎较为简单。
- 以相对安全形式提供可供全局访问的数据。

**缺点**：

- 难以完全正确实现，安全隐患在各种特殊情况下可能仍然存在，防不胜防。
  - 该设置为 `delete` 和 `private` 的构造、析构函数都应该正确设置，朴素的实现方法也未必能保证线程安全。
- 违反了面向对象单一职责原则。
- 滥用这种方法会使得实际依赖关系变得隐蔽。
  - 开发者无需在意类之间关系，只需引用单例即可。

### 工厂（Factory）模式

#### 需求：泡茶程序

根据需求提供绿茶或红茶。

```cpp
class Tea
{
    // ...
};
class GreenTea : public Tea
{
    // ...
};
class BlackTea : public Tea
{
    // ...
};
GreenTea *orderGreenTea()
{
    GreenTea *greenTea = new GreenTea();
    greenTea->addIngredients();
    greenTea->brew();
    greenTea->pour();
    return greenTea;
}
BlackTea *orderGreenTea()
{
    BlackTea *blackTea = new BlackTea();
    blackTea->addIngredients();
    blackTea->brew();
    blackTea->pour();
    return blackTea;
}
```

C++

Copy

可见代码中的大量冗余。

#### 优化：抽象出公共逻辑

当然也可以稍作修改：

```cpp
Tea *orderTea(const string &type)
{
    Tea *tea = nullptr;
    if (type == "GreenTea")
        tea = new GreenTea;
    else
        if (type == "BlackTea")
            tea = new BlackTea;
    tea->addIngredients();
    tea->brew();
    tea->pour();
    return tea;
}
```

C++

Copy

这种构造过程可能多次用到，也可以进一步抽象。

#### 工厂模式

在 `Tea` 类中添加一个 `factory` 静态方法。

```cpp
class Tea
{
    // ...
public:
    static Tea *factory(const string &type);
};

// ...子类定义...

Tea *Tea::factory(const string &type)
{
    if (type == "GreenTea")
        return new GreenTea;
    else
        if (type == "BlackTea")
            return new BlackTea;
        else // ...其他可能
}
```

C++

Copy

这也就是**工厂模式**。

#### 单独工厂类

当构造逻辑过于复杂，或者有必要进行分离时，可以把工厂放在单独类中。

```cpp
class TeaFactory
{
public:
    void setMilk(int amount)
    {
        // ...
    }
    void setSugar(int amount)
    {
        // ...
    }
    Tea *createTea(const string &type)
    {
        Tea *tea = nullptr;
        if (type == "GreenTea")
            tea = new GreenTea;
        else if (type == "BlackTea")
            tea = new BlackTea;
        else // ...其他可能
        if (milkAmount > 0) tea->addMilk(...);
        if (sugarAmount > 0) tea->addSugar(...);
        // ...其他属性配置
    }
};
```

C++

Copy

实际上抽象来看就是：

![21](https://wzf2000.top/wordpress/wp-content/uploads/2020/07/21.png)

#### 工厂模式用途

- 包装复杂的构造逻辑。

  

- 为重载的构造函数提供描述性名称。

  - 一些类可能具有多个重载的构造函数，可以改写为工厂模式以使用描述性名称，方便实例化操作。
  - 比如复数从平面坐标构造和极坐标构造两种方式，这两种方式参数类型恰好相同，使用工厂模式更方便也更直观。

- 对象构造需要用到当前函数体无法访问的信息。

  - Box2D 是一个物理引擎，继承了大量物理力学、运动学的计算，并将物理模拟过程封装到类对象中。

    

  - 只须调用引擎中相关对象、函数，就可模拟实现各种物理运动。

  - 使用时物理情境下设置物体，引擎即可自行按照物理规则模拟。

  - 其中类型包括 `b2Body`、`b2World`、`b2BodyDef`，分别表示刚体对象、物理场景以及 `b2Body` 对象拥有的属性。

  - 其中 `b2Body` 的构造函数为私有，必须使用工厂模式构造：

  ```cpp
  b2World *world = new b2World(gravity(0.0f, -10.0f), ...);
  b2BodyDef bodyDef;
  bodyDef.position.Set(0.0f, 4.0f);
  // ...
  b2Body *body = world->createBody(&bodyDef);
  ```

  C++

  Copy

  其构造需要使用到 `bodyDef` 中的内容。

- 需要集中管理被构造对象的生命周期。

  - 上述例子中 `b2World` 维护了所有 `b2Body` 的列表，这一列表是私有的，可以用于管理其生命周期。
  - 而且使用这样的方法，可以使得实例化 `b2Body` 时**无需给出所有属性**，并可以**方便地构造多个属性相同、类似的对象**。
  - 除此之外，Box2D 自己实现了小块内存分配器，手动管理内存，人工进行实例化反而会与自动内存分配冲突。
  - 也就是说工厂模式可以避免用户误用系统的内存分配机制，让创建过程不暴露给用户。

### 抽象工厂（Abstract Factory）模式

#### 工厂模式局限

工厂模式目的是构造单个类对象。

如果我们需要构造多个类对象，而且有特定组合方式？

#### 需求：编译器前端

一个实例：编译器前端。

- 编译器前端负责由代码构建统一格式的中间表示。
- 通常来说，需要三个步骤，语法分析、语义分析、中间代码生成。
- 对于每种语言来说，每个步骤的实现不同，同种语言应该使用同种实现。
- 编译器前端的框架相同，只须替换是三个步骤不同实现即可。
- 不妨假设有两种语言 C++ 和 Java。

#### 设计

三个步骤类：

- **语法分析**：基类 `Lexer`，`cppLexer`，`JavaLexer`。
- **语义分析**：基类 `Parser`，`CppParser`，`JavaParser`。
- **中间代码生成**：基类 `Generator`，`CppGenerator`，`JavaGenerator`。

框架实现：

```cpp
class Compiler
{
    string type;
public:
    Compiler(string _type) : type(_type) {}
    LexResult *lex(Code *input)
    {
        Lexer *lexer;
        if (type == "cpp")
            lexer = new CppLexer;
        else if (type == "java")
            lexer = new JavaLexer;
        return lexer->lex(input);
    }
    // ...其他两部分类似
};
```

C++

Copy

#### 框架实现细节

上述工厂模式实现合理，但是有较多代码重复，并且如果需要**增加新语言**，需要在每个步骤都加上 `if` 分支。

我们如何在当前框架下减少代码重复。

#### 分析：添加一层抽象

设计一个基类，抽象统一语言所需的所有步骤：

```cpp
class AbstractLanguageFactory
{
public:
    virtual Lexer *createLexer() = 0;
    virtual Parser *createParser() = 0;
    virtual Generator *createGenerator() = 0;
};

class CppFactory : public AbstractLanguageFactory
{
public:
    Lexer *creater()
    {
        return new CppLexer;
    }
    // ...其他两部分类似
};
class JavaFactory : public AbstractLanguageFactory
{
    // ...类似
};
```

C++

Copy

则上述 `Compiler` 类可以改写为：

```cpp
class Compiler
{
    AbstractLanguageFactory *factory;
public:
    Compiler(AbstractLanguageFactory *_factory) : factory(_factory) {}
    LexResult *lex(Code *input)
    {
        Lexer *lexer = factory->createLexer();
        return lexer->lex(input);
    }
    // ...其他两部分类似
};
```

C++

Copy

调用时只需：

```cpp
int main()
{
    CppFactory *cppFactory = new CppFactory();
    Compiler *cppCompiler = new Compiler(cppFactory);

    Cod *code = ...
    LexResult = *lex = cppCompiler->lex(code);
    // ...
}
```

C++

Copy

#### 抽象工厂模式

对应术语与类：

- 抽象工厂：`AbstractLanguageFactory`。
- 具体工厂：`CppFactory`、`JavaFactory`。
- 抽象产品：`Lexer`、`Parser`、`Generator`。
- 具体产品：`CppLexer`、`JavaParser` 等。

抽象工厂模式，即将同类具体产品包装为一个具体工厂，以抽象工厂形式传递给上层代码。

上层代码只需要关心抽象工厂和抽象产品，无需知道具体工厂、产品是哪些。

![22](https://wzf2000.top/wordpress/wp-content/uploads/2020/07/22.png)

抽象工厂模式是工厂模式的升级版，用于创建一组相关或相互依赖的对象。

### 总结

#### 创建型模式

创建型模式是将对象的创建与使用进行划分，规避复杂对象创建带来的资源消耗，满足特殊情况的创建要求。

上面的三种设计模式分别有不同的创建需求，因此有了不同的实现。

#### 设计模式总结

日常任务实际上往往是多种设计模式的综合。

比如策略模式实例化可能过于复杂，可以采用抽象工厂模式进行策略创建的封装。

比如数据存储采用迭代器模式，而数据结构又可以采用适配器模式。

总的来说，设计模式存在的目的是为了**面向未来、面向变化**：

- 进行代码复用。
- 支持功能拓展。
- 降低维护代价。
- 方便外部调用。

理解与应用也应该将重点放在**设计思路**而非具体实现代码，也不应该**过度设计框架**，避免过于精巧设计给实现带来不便。

## L_17并发编程与并发设计模式*

### 并发编程

#### 并发与并行

**并发**：

- 在一个时间段内几个程序都处于启动到完成之间。
- **任意时刻**仅**一个程序**在计算单元上**运行**。
- 宏观上同时，微观上仍然顺序执行。
- 比如多个队列交替使用同一台机器就是并发。

**并行**：

- 在一个时间段内几个程序都处于启动到完成之间。
- **任意时刻**可以有多个程序同时运行。
- 宏观微观均为同时。
- 比如多个队列同时使用多台机器就是并行。

两者都是多任务环境下的系统。

一般来说：

- 支持多任务同时存在，就可认为是**并发系统**。
- 支持多任务同时执行，就可认为是**并行系统**。
- 并发、并行主要区别为是否存在多个处理器同时处理多个任务。

为了简化问题，不考虑处理器数量情况下，我们统称为**并发**。

#### 并发编程的必要性

非并发程序执行时间常常受到算法时间复杂度以及计算设备的性能影响。

然而现代计算设备的发展使得 **CPU 单核性能难以突破**，发展转为核的增长，并且出现了 **GPU 等高度并行的计算设备**。

因此，掌握并发编程技术是充分发挥计算设备运算能力的基础。

#### 进程与线程

**进程**：

- 计算机中已经运行的程序。

**线程**：

- 操作系统可进行**运算调度**的最小单位。
- 被包含在进程中，是进程中的实际运作单位。
- **一个进程**可以**并发多个线程**，设备允许的情况下，数个线程可以并发执行不同任务。
- 同一进程的多条线程共享该进程中的**所有系统资源**，包括虚拟地址空间、文件描述符、信号处理等。

一般来说，程序通常会在一个进程中运行，而一个进程至少包含一个线程，即**主线程**。

默认情况下，代码都是在进程的主线程中运行，除非程序中创建了新线程。

当系统仅有一个计算内核时，所有进程、线程会**分时占用**这个内核。

若存在多个，则多个进程、线程可**并行**在不同内核上。

一般所说的 **CPU 核数、线程数**就是指 **CPU 的物理核心和逻辑核心数量**，可以体现处理器的并行能力。

进程与线程是程序运行调度的基础，也是并发编程的操作对象。

### `thread` 与主从模式

#### 需求：计算 11 到 50000005000000 之间的素数

理论上这个当然可以通过简单的线性筛得出，但这里我们希望通过朴素的枚举因子法判断一个数是否为素数。

也就是判断是否存在其根号以下的非 11 因子。

常规做法耗时巨大，需要约 1212 秒。

在不进行算法改进的前提下，可以使用并发编程优化。

#### `thread` 类

其默认构造函数定义为：

```cpp
thread() noexcept;
```

C++

Copy

创建一个空线程对象，不代表任何可执行的线程。

比如：

```cpp
#include <thread>

using namespace std;

int main()
{
    thread s1;
    return 0;
}
```

C++

Copy

而初始化构造函数定义为：

```cpp
template <class Fn, class... Args>
explicit thread(Fn&& fn, Args&& ... args);
```

C++

Copy

使用时需要给定入口函数 `fn`，并且 `fn` 函数的参数由 `args` 给出。

这里的 `fn` 需要是可调用表达式，包括函数、函数对象、lambda 表达式等。

与普通对象创建不一样的是，这里编译器会创建一个新的操作系统线程，线程启动后会执行入口函数。

**注意**：线程一旦创建，线程就开始执行。

#### `join()` 与 `detach()`

`thread` 线程一旦创立，就开始执行。

但我们可能仍需要对当前线程与目标线程进行协调，因此 `thread` 提供了两种接口来协调当前线程与目标现成：

- ```
  thread::join()
  ```

  ：

  - 调用此接口，当前线程会一直阻塞，直到目标线程执行完成。

- ```
  thread::detach()
  ```

  ：

  - 调用此接口时，目标线程将成为**守护线程（daemon threads）**，将完全独立执行。
  - 即使目标线程对应的 `thread` 对象被销毁也不影响线程的执行。

如：

```cpp
#include <iostream>
#include <thread>
#include <chrono>
using namespace std;

void test(int seconds)
{
    this_thread::sleep_for(chrono::seconds(seconds));
}

int main()
{
    thread t1(test, 3);
    t1.join();
    // 此处由于 t1.join() 导致主线程阻塞，主线程须等待 t1 执行 3s 后才能继续执行
    this_thread::sleep_for(chrono::seconds(6));
    return 0;
}
```

C++

Copy

可知总共运行约 99 秒。

但如果交换 `t1.join()` 与后一句的顺序，则由于 `t1` 指向的线程与主线程会同时进行，运行到 `t1.join()` 时 `t1` 指向的线程已经完成，因此不会发生阻塞，总共运行 66 秒。

又比如：

```cpp
#include <iostream>
#include <thread>
#include <chrono>
using namespace std;

void test(int seconds)
{
    this_thread::sleep_for(chrono::seconds(seconds));
}

int main()
{
    thread t1(test, 3);
    t1.detach();
    // 此时 t1 指向线程与当前线程脱钩，两者独立，当前延时操作也就不会被阻塞
    this_thread::sleep_for(chrono::seconds(6));
    return 0;
}
```

C++

Copy

总共运行 66 秒。

#### 拷贝构造函数

定义为：

```cpp
thread(const thread &) = delete;
```

C++

Copy

也就是说拷贝构造函数被禁用，因而 `thread` 不可被拷贝构造。

这是由于线程涉及系统底层，无法拷贝。

#### 移动构造函数

定义为：

```cpp
thread(thread&& x) noexcept;
```

C++

Copy

有默认的移动构造函数。

调用成功后 `x` 不指向任何具体执行线程。

比如如下程序可以照常进行：

```cpp
thread t1;
thread t2(test, 3);
t1 = move(t2);
t1.join();
```

C++

Copy

但若改为 `t2.join()`，则会产生系统错误。

#### `joinable()`

`thread::joinable()` 可判断 `thread` 实例指向的线程是否可以 `join()` 或 `detach()`。

返回 `true` 表示可以。

三种情况会使得实例返回 `false`：

- 默认构造函数创建的实例。
- 被移动构造函数操作过的实例。
- 已经调用过 `join()` 或者 `detach()` 的实例。

特别注意，启动目标线程后，我们必须决定当前线程是要等待目标线程结束（`join()`），还是让目标线程独立（`detach()`），**必须二选一**。

如果到对象被销毁时仍未做出选择，析构时将导致程序进程异常退出。

也就是说，`thread` 析构时，其 `joinable()` 必须是 `false`。

#### 其他接口

- ```
  this_thread::get_id()
  ```

  ：

  - 返回当前线程的 `id`，可以标识不同的线程。

- ```
  this_thread::sleep_for()
  ```

  ：

  - 前面已经使用，使得**当前线程**停止执行一段时间。

- ```
  this_thread::sleep_until()
  ```

  ：

  - 与上面类似，但是以具体时间点为停止参数。

- ```
  this_thread::yield()
  ```

  ：

  - 如果当前线程任务已经完成，将处理器让给其他任务使用。

#### 实现：任务划分

前面的求素数我们将其等分为四段，分别由四个线程单独解决，合并四个结果即得最终结果。

具体实现：

```cpp
#include <iostream>
#include <cmath>
#include <vector>
#include <thread>

using namespace std;

thread* threads[4];
int thread_total[4];
int total = 0, mi, mx;

bool check_num(int num)
{
    // ...具体判断略
}

void check(int l, int r, int num) 
{
    thread_total[num] = 0;
    for (int i = l; i < r; i++)
        if (check_num(i))
            thread_total[num]++; 
}

int main()
{
    mi = 1;
    for (int i = 0; i < 4; i++)
    {
        mx = mi + 5000000 / 4;
        if (mx > 5000000) mx = 5000000;
        // 为第 i 个线程分配 [mi, mx) 区间的任务
        threads[i] = new thread(check, mi, mx, i);
        mi = mx; 
    }
    // 阻塞主线程，等待所有子线程完成统计
    for (int i = 0; i < 4; i++)
        threads[i]->join();
    for (int i = 0; i < 4; i++)
    {
        total += thread_total[i];
        delete threads[i];
    }
    cout << total << endl;
    return 0; 
}
```

C++

Copy

最终耗时降为 4.54.5 秒。

实际上，这就是一种典型的并发设计模式——**主从模式**。

#### 主从模式

主从模式是最常用的并发设计模式。

- 系统由 Master 和 Worker 两部分组成。
- Master 负责接收和分配任务。
- Worker 负责处理子任务。
- 任务处理过程中：
  - Worker 负责工作。
  - Master 负责监督任务进展和 Worker 的健康状态。
  - Master 将接收 Client 提交的任务，比将任务进展汇总反馈给 Client。

其适用场景要求：

- 整体人物可被划分为诸多子任务。
- 子任务之间关联较弱，可以并发执行。
- 计算设备支持多任务同时执行。

### `mutex` 与互斥锁模式

#### 优化：减少临时变量

前面的实现中我们对于每个子任务通过 `thread_total[]` 来存储，但如果我们希望直接将结果存入 `total` 是否可能呢？

实际上直接修改会发现，尽管耗时不变，但是得出的结果减少了。

甚至进行多次运行，得出的结果也不同。

#### 竞争条件与临界区

**竞争条件**：

- 多个线程同时访问共享数据时，只要有一个任务修改数据，那么就可能发生问题——多个线程同时争相修改数据，导致部分修改失败，这也就是所谓的**竞争条件（race condition）**。

**临界区**：

- 访问共享数据的代码片段称为临界区（critical section），比如之前修改后的 `total++`。

避免竞争条件需要对临界区进行数据保护，也就是一次只让一个线程访问共享数据，其他的线程需等待其访问完成之后继续访问。

#### 互斥量与锁

C++11 提供了**互斥量（`mutex`）**来进行数据保护。

其本身是一个类对象，也常被称为**锁**。

各个线程可尝试用 `mutex` 的 `lock()` 接口来对临界区数据加锁。

每次只有一个线程可以成功锁定，成功标志是 `lock()` 成功返回。

如若失败，则线程会阻塞。

同样还有 `unlock()` 接口可以解锁互斥量，这时阻塞的其他线程又会继续尝试锁定。

#### 修改：利用 `mutex`

```cpp
#include <iostream>
#include <cmath>
#include <vector>
#include <thread>

using namespace std;

thread* threads[4];
int total = 0, mi, mx;

static mutex exclusive;

bool check_num(int num)
{
    // ...具体判断略
}

void check(int l, int r, int num) 
{
    for (int i = l; i < r; i++)
        if (check_num(i))
        {
            exclusive.lock();
            total++;
            exclusive.unlock();
        }
}

int main()
{
    mi = 1;
    for (int i = 0; i < 4; i++)
    {
        mx = mi + 5000000 / 4;
        if (mx > 5000000) mx = 5000000;
        // 为第 i 个线程分配 [mi, mx) 区间的任务
        threads[i] = new thread(check, mi, mx, i);
        mi = mx; 
    }
    // 阻塞主线程，等待所有子线程完成统计
    for (int i = 0; i < 4; i++)
        threads[i]->join();
    for (int i = 0; i < 4; i++)
        delete threads[i];
    cout << total << endl;
    return 0; 
}
```

C++

Copy

当然也可以再加修改（优化）：

```cpp
#include <iostream>
#include <cmath>
#include <vector>
#include <thread>

using namespace std;

thread* threads[4];
int total = 0, mi, mx;

static mutex exclusive;

bool check_num(int num)
{
    // ...具体判断略
}

void check(int l, int r, int num) 
{
    int tmp_total = 0;
    for (int i = l; i < r; i++)
        if (check_num(i))
            tmp_total++;
    exclusive.lock();
    total += tmp_total;
    exclusive.unlock();
}

int main()
{
    mi = 1;
    for (int i = 0; i < 4; i++)
    {
        mx = mi + 5000000 / 4;
        if (mx > 5000000) mx = 5000000;
        // 为第 i 个线程分配 [mi, mx) 区间的任务
        threads[i] = new thread(check, mi, mx, i);
        mi = mx; 
    }
    // 阻塞主线程，等待所有子线程完成统计
    for (int i = 0; i < 4; i++)
        threads[i]->join();
    for (int i = 0; i < 4; i++)
        delete threads[i];
    cout << total << endl;
    return 0; 
}
```

C++

Copy

这样便可以在获得正确结果、耗时不变的前提下，简化代码。

这也就是典型的**互斥锁设计模式**。

#### 互斥锁模式

互斥锁模式是最基本的并行数据处理模式：

- 访问共享资源之前进行加锁操作。
- 访问完成之后进行解锁操作。
- 加锁后，其他试图加锁的线程均会阻塞，就如前面所说，直到当前线程解锁才会继续尝试加锁。

其**弊端**也十分明显，也就是**低效**，共享资源的读操作往往无需互斥。

解决方案也就是采用读写锁模式，读共享，而写互斥。

#### 其他互斥量

C++11 之后提供了丰富的各类互斥量：

- ```
  timed_mutex
  ```

  ：

  - 带超时功能，一定时间内未取得锁，则直接返回，不再继续等待。

- ```
  recursive_mutex
  ```

  ：

  - 能被同一线程递归锁定的互斥量，即在同一个线程中，同一把锁可以被锁定多次。

- ```
  recursive_timed_mutex
  ```

  ：

  - 上述功能的综合体。

- ```
  shared_mutex
  ```

  ：

  - 共享互斥量，实际上提供了两把锁，一把共享锁，一把互斥锁，常用于读写锁模式。

更多相关参考书：

- **《深入理解并行编程》**。
- **《C++ Concurrency in Action》**。

### `async()`、`future`、`promise` 与异步

#### 需求：动态判断是否为素数

不断输入整数 nn，判断 nn 是否为素数。

尽管 `thread` 可以提高素数计数的速度，然而第 n+1n+1 次输入仍需要等待第 nn 次判断结束方可执行。

能否让输入不受判断方法的阻塞？

或者说利用并发编程实现某种意义上的”离线“？

#### 同步与异步

**同步（Synchronous）**：

- 同步调用一旦开始，调用者必须等到调用返回结果才可继续后续行为。

![23](https://wzf2000.top/wordpress/wp-content/uploads/2020/07/23.png)

**异步（Asynchronous）**：

- 异步调用一旦开始，被调用方法就会立即返回，调用者可无阻塞继续后续操作。
- 被调用方法通常会在另外一个线程中默默运行，整个过程不会阻碍调用者的工作。
- 被调用方法完成后可以通过特殊机制传递信息给调用者。

![24](https://wzf2000.top/wordpress/wp-content/uploads/2020/07/24.png)

#### `async()`

很多变成语言，比如 JavaScript，都提供了异步执行机制，这也使得耗时的机制不会影响当前线程的整体执行。

而 C++11 中 `async()` 便有异步的功能。

其定义为：

```cpp
future async(Fn&& fn, Args&& ... args);
future async(launch policy, Fn&& fn, Args&& ... args);
```

C++

Copy

与 `thread` 的入口类似，包括入口函数 `fn` 以及其参数 `args`。

函数会返回一个 `future` 对象，用于存储异步任务执行状态和结果。

`policy` 有三种选择：

- `launch::async`：保证异步行为，系统创建一个线程执行对应的函数。
- `launch::deffered`：表示延迟调用，在调用 `future` 的 `wait()` 或 `get()` 函数后，才执行入口函数。
- `launch::async || launch::deffered`：默认策略，系统自主决定调用方式。

#### 初步实现：利用 `async()`

```cpp
#include <iostream>
#include <future>
#include <cmath>
using namespace std;

bool check_num(int num)
{
    bool flag = true;
    if (num == 1)
        flag = false;
    else
        for (int i = sqrt(num); i > 1; i--)
            if (num % i == 0)
            {
                flag = false;
                break;
            }
    if (flag)
        cout << num << " is a prime number" << endl;
    else
        cout << num << " is not a prime number" << endl;
    return flag;
}

int main()
{
    std::future<bool> fut = async(check_num, 194232491);
    cout << "check the number ..." << endl;
    return 0;
}
```

C++

Copy

运行结果为：

```
check the number ...
194232491 is a prime number
```

同理也可以改为 lambda 表达式等其他可调用对象。

#### `future`

`future` 提供访问异步操作结果的接口：

- `wait()` 接口，阻塞当前线程，等待异步线程结束。

- ```
  get()
  ```

   

  接口，获取异步线程执行结果。

  - `future` 对象只能被一个线程获取值，并且在调用 `get()` 过后，就没有可获取的值了。
  - 若多个线程调用同一实例的 `get()` 造成数据竞争，结果未定义。
  - `get()` 后如果异步线程没有结束，会一直等待，类似 `wait()`。

- ```
  wait_for(timeout_duration)
  ```

   

  如果在指定的超时间隔后仍然无法结束异步线程，则返回当前状态，取消其阻塞。

  - `future_status::deferred`：仍未启动。
  - `future_status::ready`：结果就绪。
  - `future_status::timeout`：超过时限，但异步线程仍在执行。

#### 实现：利用 `async()` 和 `future`

```cpp
#include <future>
#include <chrono>
#include <vector>
#include <thread>
#include <random>
#include <iostream>

using namespace std;

int total = 0;
bool check_num(int num)
{
    // ...具体判断略
}

// 设置一个随机来代替输入
default_random_engine e;
int input()
{
    return e();
}

// 存放异步调用的 future 和输入数值
vector<future<bool> > future_lists;
vector<int> num_lists;

int main()
{
    while (true)
    {
        int num = input();
        future_lists.push_back(async(check_num, num));
        num_lists.push_back(num);

        for (int i = future_lists.size() - 1; i >= 0; i--)
        {
            // 每个 future 等待 0.1 秒来检测状态
            future_status status = future_lists[i].wait_for(chrono::milliseconds(100));
            if (status == future_status::ready)
            {
                if (future_lists[i].get())
                    cout << num_lists[i] << " is a prime number" << endl;
                else
                    cout << num_lists[i] << " is not a prime number" << endl;
                // 删除已经完成任务的 future
                future_lists.erase(future_lists.begin() + i);
                num_lists.erase(num_lists.begin() + i);
            }
        }
    }
    return 0;
}
```

C++

Copy

使用异步线程进行运算，并通过主线程进行状态管理。

主线程不断检查输入状态和异步线程的执行状态，有输入则创建新线程，某一异步线程完成则立刻输出结果。

这种不断消耗极短时间进行检测的方式即为**轮询**。

#### 轮询

轮询是服务器与客户端开发常用范式。

客户端：

- 客户端向服务器上传，每隔一段时间检测上传是否完成。
- 未完成时，上传操作不阻塞客户端其他操作，只有检测的微笑瞬间产生阻塞。

服务器端：

- 服务器为客户端处理耗时较大的任务时，也会开启异步线程在后台处理任务。
- 间隔一段时间，服务器就会确认任务是否完成。
- 整个过程也不影响服务器其他操作，比如接受反馈客户端的请求。

当然，管理轮询的线程也可以开启单独线程，而不是利用主线程。

![25](https://wzf2000.top/wordpress/wp-content/uploads/2020/07/25.png)

#### `promise`

为了更好满足跨线程取值需求，C++ 还提供了 `promise` 来配合 `future`。

`future` 对象只能被一个线程获取值，并且调用 `get()` 之后，就无法再获取。

之前 `future` 对象需要在异步线程完成后返回值，这也十分不方便。

**一般流程**：

- 在当前线程中创建 `promise` 对象，并从该 `promise` 对象中获得对应的 `future` 对象。
- 将 `promise` 对象传给目标线程，目标线程通过 `promise` 的接口设置特定值，然后可继续执行目标线程自身的工作。
- 在特定时间，当前线程按需求通过 `promise` 对应的 `future` 取值。

#### 优化：利用 `promise`

```cpp
void check_num(int num, promise<bool>* res_promise)
{
    if (num == 1)
    {
        res_promise->set_value(false);
        return;
    }
    for (int i = sqrt(num); i > 1; i--)
        if (num % i == 0)
        {
            res_promise->set_value(false);
            return;
        }
    res_promise->set_value(true);
}

int main()
{
    int num = 194232491;
    promise<bool> res_promise;
    future<bool> res_future = res_promise.get_future();

    thread worker(check_num, num, &res_promise);
    worker.detach();

    if (res_future.get())
        cout << num << " is a prime number" << endl;
    else
        cout << num << " is not a prime number" << endl;
    return 0;
}
```

C++

Copy

通过 `promise` 的 `get_future()` 接口获得配对的 `future`。

此处通过 `future` 与 `promise` 之间的联系，使得结果可以传递，因此可以使用 `detach()` 使得 `worker` 线程独立于当前线程。

最后在通过 `future` 的 `get()` 获取结果即可。

这样可以更好的控制在何处获取 `future` 的结果。

#### `promise` 总结

`promise` 的功能和其自身的翻译承诺类似。

工作线程将结果存入 `promise`，只有 `promise` 应允的 `future` 才能获取到值。

这也就是通过状态统治调用者的异步方法。

而回调方法则暂时不做介绍。

### 总结

主要介绍的是 C++ 的并发编程技术以及并发设计模式，与前面的设计模式有着很大的不同，这也是专门开一讲来介绍的原因。